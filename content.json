{"meta":{"title":"ala's blog","subtitle":"后来我就念了两首诗","description":"想到哪写到哪","author":"ala","url":"https://moeologist.github.io","root":"/"},"pages":[],"posts":[{"title":"JavaScript 中的 var 和 let","slug":"var-vs-let","date":"2019-08-09T16:01:43.196Z","updated":"2020-10-03T06:41:57.087Z","comments":true,"path":"var-vs-let/","link":"","permalink":"https://moeologist.github.io/var-vs-let/","excerpt":"一个例子 看下面一个例子：","text":"一个例子 看下面一个例子： var change = \"hello\";function f() &#123; var change = \"scram\";&#125;f();console.log(change); // 输出 scram 好吧，这里 change 的值被改变成了 “scram”，一个全局变量居然在一个函数的作用域里被“重新声明”了。 我们除了用 var 定义变量，也可以不加关键字直接写出来，以及 es6 的新特性 let 和 const，这里仅仅总结一下他们的行为。 var var 关键字当前定义域中定义一个变量，当变量已经存在与外层作用域时，var 仅仅对其赋值，就像前面演示的一样。 等于表达式 而形如 variable = value 的表达式优先在内层作用域内查找变量进行赋值，没有找到时在全局作用域定义 variable 并赋值，参见下面的例子： function f() &#123; function g() &#123; v = \"hello\"; &#125; g();&#125;f();console.log(v); // 输出 hello let 以及 const let 关键字就像我们在在其他语言中所做的工作一样。不同作用域的同名变量视为不同的变量。值得一提的是，在同一个作用域下 var 可以重复声明一个变量，而 let 不能。 const 和 let 相同但不接受重赋值操作。 let v = \"hello\";function f() &#123; let v = \"hello world\"; console.log(v); // 输出 hello world&#125;f();console.log(v); // 输出 hello var a = \"foo\";var a = \"bar\"; // 可以let b = \"var\";let b = \"let\"; // 重定义错误let a = \"strict\"; // 重定义错误 Hoisting 另外一个值得一提的概念——变量提升（Hoisting），首次出现在 ECMAScript® 2015 Language Specification 中，MDN上描述： 变量提升意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 可以考虑下面的例子 // file-1.jsconsole.log(x); // 输出 undefined，似乎并不对未定义的 x 感冒var x;// file-2.jsconsole.log(x); // ReferenceError: x is not defined 对于函数有： f(); // 没有问题function f() &#123; console.log(\"hello\");&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://moeologist.github.io/categories/Web/"}],"tags":[]},{"title":"动态规划笔记","slug":"knapsack","date":"2019-08-09T16:01:43.173Z","updated":"2020-10-07T12:32:33.815Z","comments":true,"path":"knapsack/","link":"","permalink":"https://moeologist.github.io/knapsack/","excerpt":"前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。","text":"前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。 序列相关问题 这类问题通常写作最XX子序列的问题，实际上是是一类 最优子结构 问题，往往能用动态规划轻松解决。 最长上升子序列（LIS） 在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。注意最长递增子序列中的元素在原序列中不一定是连续的。 解法 值得一提的是 —— 这类问题一般只要求出最优解就可以。 设串为 sss，第 iii 个元素为 sis_isi​，以第 iii 个元素结束的 LIS 为 LIS(i)\\text{LIS}(i)LIS(i)，LIS(i)\\text{LIS}(i)LIS(i) 长度为 DiD_{i}Di​，那么 DiD_{i}Di​ 只可能等于 Dj+1D_j+1Dj​+1（0≤j&lt;i0 \\le j \\lt i0≤j&lt;i），即 LIS(i)\\text{LIS}(i)LIS(i) 一定是某个 LIS(j)\\text{LIS}(j)LIS(j) 的尾部增添 sis_isi​ 构成的，约束 sj&lt;sis_j \\lt s_isj​&lt;si​ 并取所有 LIS(j)\\text{LIS}(j)LIS(j) 的最大值赋给 DiD_{i}Di​。边界 D0=0D_0=0D0​=0，从 D0D_0D0​ 转移意味着 sis_isi​ 不满足任何 sj&lt;sis_j \\lt s_isj​&lt;si​ ，则 LIS(j)\\text{LIS}(j)LIS(j) 是仅含有 sis_isi​ 的单元素序列。总的结果是 max⁡0&lt;i≤N(Di)\\displaystyle \\max_{0 \\lt i \\le N} (D_i)0&lt;i≤Nmax​(Di​)。数学表达如下： Di=max⁡0≤j&lt;i,sj&lt;si(Dj)+1D_{i}= \\displaystyle \\max_{0 \\le j \\lt i, s_j \\lt s_i} (D_j)+1Di​=0≤j&lt;i,sj​&lt;si​max​(Dj​)+1这类表达式被称作 状态转移方程。 #define N 9int s[N] = &#123;10, 11, 13, 9, 6, 5, 4, 7, 14&#125;;int D[N] = &#123;&#125;;for (int i = 0; i &lt; N; ++i) D[i] = 1;for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i; ++j) if (s[j] &lt; s[i]) D[i] = max(D[i], D[j] + 1);return *max_element(D, D + N); 优化 上面解的时间复杂度是 O(N2)O(N^2)O(N2)，使用二分法可以将时间复杂度降低到 O(Nlog⁡(N))O(N\\log(N))O(Nlog(N))，动态规划方法除了实现更容易似乎没有什么优势。实际上，换个思路，动态规划方法也能将时间复杂度降低到 O(Nlog⁡(N))O(N\\log(N))O(Nlog(N))。 设 长度为 kkk 的最优上升子序列 为 SkS^kSk（什么是最优暂不讨论），它的尾元素值构成数组 DkD_kDk​，DDD 初始化为空数组，空数组 DDD 可以看成是严格单调增的。考察每个元素 iii，如果所有 DkD_kDk​ 都满足 Dk&lt;siD_k \\lt s_iDk​&lt;si​，那么 DDD 数组尾部增添一个元素 sis_isi​，LIS 长度增长 111；如果并非所有 DkD_kDk​ 都满足，那第一个恰不满足 Dk&lt;siD_k \\lt s_iDk​&lt;si​ 的 DkD_kDk​ 应该被更新为 sis_isi​，意味着该 DkD_kDk​ 对应的 SkS^kSk 被更新为 Sk−1S^{k-1}Sk−1 加上后缀 sis_isi​，这个序列被认为是比原序列更优的，因为该序列性质和原序列相同，并持有持有 更小 的尾元素，更小的尾巴更有利于序列增长（若原序列加上后缀 sis_isi​ 为上升序列，则新序列加上后缀 sis_isi​ 必定也是上升序列，反之不成立）。 思路非常绕但是实现很简单： int D[N] = &#123;&#125;;int len = 0;for (int i = 0; i &lt; N; ++i) &#123; int pos = lower_bound(D, D + len, s[i]) - D; // lower_bound返回有序数组D中第一个不小于s[i]的元素对应的迭代器 D[pos] = s[i]; len = max(len, pos + 1);&#125;return len; lower_bound 实现了二分查找，故总的时间复杂度是 O(Nlog(N))O(Nlog(N))O(Nlog(N))，这个算法比朴素的二分查找简洁，运行效率也更高。 求解最优方案 如果需要求最优解具体对应的方案，问题就不那么容易了。还要注意除非题目有约束，否则最优的方案可能不止一个。回顾下前面的解，也许立即就能意识到：状态转移的过程就是取方案的过程，只要记录下状态转移的过程，最优解的方案就到手了。 为了代码好写，这里记录未优化的方案，并假设最优方案唯一： #define N 9int s[N] = &#123;0, 4, 9, 8, 7, 6, 5, 1, 2&#125;;int D[N] = &#123;&#125;;int S[N] = &#123;&#125;;for (int i = 0; i &lt; N; ++i) D[i] = 1;for (int i = 0; i &lt; N; ++i) S[i] = -1;for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i; ++j) if (s[j] &lt; s[i] &amp;&amp; D[i] &lt; D[j] + 1) &#123; D[i] = D[j] + 1; S[i] = j; &#125;int M = max_element(D, D + N) - D;for (int i = M; i != -1; i = S[i]) printf(\"%d-&gt;\",S[i]);print(\"^\") 该算法回溯DP数组，以逆序输出解方案的序列。注意题设不能保证最优方案唯一时，本算法依然输出其中一个解（这个解特殊吗？）如果我们希望输出所有的解，那么需要用二维数组记录转移状态，而且回溯DP数组的算法也是 O(N2)O(N^2)O(N2) 的。后面的问题包括背包问题，都可以用此法给出解的方案，不再赘述。 最长公共子序列（LCS） 一个数值序列，如果分别是两个数值序列的子序列，且是所有符合此条件的序列中最长的，则称为已知序列的最长公共子序列。 解法 设两个串分别为 X,YX,YX,Y, 它们的 LCS 是 LCS(X,Y)\\text{LCS}(X,Y)LCS(X,Y)，XiX^iXi 是串 XXX 长度为 iii 的前缀，YjY^jYj 是串 YYY 长度为 jjj 的前缀，Di,jD_{i,j}Di,j​ 是 LCS(Xi,Yj)\\text{LCS}(X^i,Y^j)LCS(Xi,Yj) 的长度。考察所有的前缀组合，当 XiX^iXi 和 YjY^jYj 的尾元素相等（Xii=YjjX^i_i=Y^j_jXii​=Yjj​）时， XiX^iXi 和 YjY^jYj 都是 LCS(Xi,Yj)\\text{LCS}(X^i,Y^j)LCS(Xi,Yj) 的尾元素，或者说 LCS(Xi−1,Yj−1)\\text{LCS}(X^{i-1},Y^{j-1})LCS(Xi−1,Yj−1) 尾部增添此元素构成 LCS(Xi,Yj)\\text{LCS}(X^i,Y^j)LCS(Xi,Yj)，则 Di,j=Di−1,j−1+1D_{i,j}=D_{i-1,j-1}+1Di,j​=Di−1,j−1​+1；如果 Xii≠YjjX^i_i \\ne Y^j_jXii​​=Yjj​，则 Di,jD_{i,j}Di,j​ 只能从 Di−1,j,Di,j−1,Di−1,j−1D_{i-1,j},D_{i,j-1},D_{i-1,j-1}Di−1,j​,Di,j−1​,Di−1,j−1​ 中的最大者转移，因为这些 DDD 分别对应的 LCS\\text{LCS}LCS 一定也是 XiX^iXi 和 YjY^jYj 的公共子序列，三个 DDD 分别对应：仅 XiiX^i_iXii​ 更新 LCS，仅 YjjY^j_jYjj​ 更新 LCS，XiiX^i_iXii​ 和 YjjY^j_jYjj​ 都不能更新 LCS。边界 D0,j=0,Di,0=0D_{0,j}=0, D_{i,0}=0D0,j​=0,Di,0​=0： same(x,y)={0if si≠tj1if si=tjsame(x,y)= \\begin{cases} 0 &amp;\\text{if } s_i \\ne t_j \\\\ 1 &amp;\\text{if } s_i = t_j \\end{cases}same(x,y)={01​if si​​=tj​if si​=tj​​Di,j=max⁡{Di−1,j−1+same(Xi,Yj),Di−1,j,Di,j−1}D_{i,j}=\\max\\{ D_{i-1,j-1}+same(X_i, Y_j), D_{i-1,j}, D_{i,j-1} \\}Di,j​=max{Di−1,j−1​+same(Xi​,Yj​),Di−1,j​,Di,j−1​}实现细节 因为 Di−1,j−1D_{i-1,j-1}Di−1,j−1​ 小于 Di−1,j−1+same(Xi,Yj)D_{i-1,j-1}+same(X_i, Y_j)Di−1,j−1​+same(Xi​,Yj​)，所以它没有办法影响状态转移，可以从 max⁡\\maxmax 函数里去除，实际上，Di−1,j−1D_{i-1,j-1}Di−1,j−1​一定最小的，Di−1,j−1+1D_{i-1,j-1}+1Di−1,j−1​+1 一定是最大的（为什么？） char x[] = \"abcde\";char y[] = \"accabcdcced\";int n = strlen(x);int m = strlen(y);int D[2][m]; // VLA，在C++里属于GNU扩展功能，可以动态分配内存或用vectormemset(D, 0, 2 * m * 4);for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) D[(i + 1) % 2][j + 1] = max(D[i % 2][j] + int(x[i] == y[j])), D[i % 2][j + 1], D[(i + 1) % 2][j]);return D[n % 2][m]; 因为二维数组中，元素依赖的项目只有上一行 i−1i-1i−1，上面的算法交替使用 2×m2 \\times m2×m 数组的行来节省空间复杂度。这是一种通用的优化动态规划空间复杂度的方法。 更多个序列的 LCS 类比两个序列的情况，状态转移方程加一维，有： Di,j,k=max⁡{Di−1,j−1,k−1+same(Xi,Yj,Zk),Di−1,j,k,Di,j−1,k,Di,j,k−1}D_{i,j,k}=\\max\\{ D_{i-1,j-1,k-1}+same(X_i, Y_j, Z_k), D_{i-1,j,k}, D_{i,j-1,k}, D_{i,j,k-1} \\}Di,j,k​=max{Di−1,j−1,k−1​+same(Xi​,Yj​,Zk​),Di−1,j,k​,Di,j−1,k​,Di,j,k−1​}扩展阅读 LCS 实际上是很多实际问题的基础，比如著名的GNU diff。正因为如此，许许多多的科学工作者研究了这个问题，并给出了一些一定条件下的更优解。读者可以自行阅读wiki。 编辑距离 编辑距离可以看成 LCS 问题的扩展，因为比较实用且变种较多所以额外提及一下： 在计算语言学和计算机科学中，编辑距离是一种通过计算将一个字符串转换为另一个字符串所需的最小操作数来量化两个字符串（例如单词）彼此之间有多么不同的方式。 Levenshtein距离允许删除，插入和置换。 最长公共子序列（LCS）距离仅允许插入和删除。 Hamming距离仅允许替换，因此，它仅适用于具有相同的长度的字符串。 Damerau-Levenshtein距离允许插入，缺失，置换，和交换的两个相邻的字符。 Jaro距离只允许交换的两个相邻的字符。 拼写矫正，DNA序列相似度分析，图片相似度等问题都是编辑距离的实际应用。这里给出最复杂的求Damerau-Levenshtein距离的状态转移方程，假设所有操作的费用都是1，思路类似 LCS，边界 D0,0=0D_{0,0}=0D0,0​=0： Di,j=min⁡{Di−1,j+1if i&gt;0Di,j−1+1if j&gt;0Di−1,j−1+same(si=tj)if i&gt;0,j&gt;0Di−2,j−2+1if i&gt;1,j&gt;1,si=tj−1,si−1=tjD_{i,j}=\\min \\begin{cases} D_{i-1,j}+1 &amp;\\text{if } i \\gt 0 \\\\ D_{i,j-1}+1 &amp;\\text{if } j \\gt 0 \\\\ D_{i-1,j-1} + same(s_i = t_j) &amp;\\text{if } i \\gt 0, j \\gt 0 \\\\ D_{i-2,j-2} + 1 &amp;\\text{if } i \\gt 1, j \\gt 1, s_i=t_{j-1}, s_{i-1}=t_j \\end{cases}Di,j​=min⎩⎪⎪⎪⎨⎪⎪⎪⎧​Di−1,j​+1Di,j−1​+1Di−1,j−1​+same(si​=tj​)Di−2,j−2​+1​if i&gt;0if j&gt;0if i&gt;0,j&gt;0if i&gt;1,j&gt;1,si​=tj−1​,si−1​=tj​​尽管状态转移方程的项很多，但是代码很好写，注意如果费用不是1，或者费用不是固定值，方程稍加修改就能使用，实际编码时，可以额外初始化 D0,j=j,Di,0=iD_{0,j}=j, D_{i,0}=iD0,j​=j,Di,0​=i 来减少内层循环中的条件判断。 背包问题 背包问题是一类解可以优化到伪多项式时间复杂度的NP-C问题，这类问题也常常被作为动态规划方法的入门问题被提及，最著名的就是《背包问题九讲》 0-1背包问题 Q：有 N 件物品，每件物品有其对应的重量 wiw_iwi​ 和价值 viv_ivi​，有一个总重量限制为 WWW 背包，求背包能装下的最大总价值 解法 设Di,jD_{i,j}Di,j​为前 iii 种物品在重量限制 jjj 下所能取出的最大值（限重 jjj 的背包所能装下的最大价值）。对第 iii 种物品都可以有取与不取两种选择，假设前 i−1i-1i−1 种物品在重量限制 jjj 下能获得的最大价值为 Di−1,jD_{i-1,j}Di−1,j​，如果选第 iii 种物品，Di,jD_{i,j}Di,j​ 应为 Di−1,j−wi+viD_{i-1,j-w_i}+v_iDi−1,j−wi​​+vi​；不选的话，Di,jD_{i,j}Di,j​ 为 Di−1,jD_{i-1,j}Di−1,j​。二者中更大者为问题的解： Di,j=max⁡{Di−1,j−wi+vi,Di−1,j}D_{i,j}= \\max \\{ D_{i-1,j-w_i}+v_i, D_{i-1,j} \\}Di,j​=max{Di−1,j−wi​​+vi​,Di−1,j​}实现细节 容易得知DP数组的边界 D0,0=0D_{0,0}=0D0,0​=0, 最终解为 DN,WD_{N,W}DN,W​，当 j&lt;wij \\lt w_ij&lt;wi​ 时则意味着剩余重量已经不能支持取该物品了，可以直接置 Di,j=Di−1,jD_{i,j}=D_{i-1,j}Di,j​=Di−1,j​。该算法的时间复杂度与空间复杂度均为 O(nW)O(nW)O(nW)，当直接写成深搜时大量情况被重复计算，时间复杂度是 O(2N)O(2^N)O(2N)。 #define N 5#define W 7int w[N] = &#123;2,4,3,4,3&#125;;int v[N] = &#123;1,5,3,4,2&#125;;int D[N + 1][W + 1] = &#123;&#123;&#125;&#125;;for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt;= W; ++j) if (j &lt; w[i]) D[i + 1][j] = D[i][j]; else D[i + 1][j] = max(D[i][j], D[i][j - w[i]] + v[i]);return D[N][W]; 注意 DDD 下标 1 指代第一种物品，w,vw,vw,v 下标 0 指代第一种物品。 《背包问题九讲》提到一个初始化细节，将 D0,j(j≠0)D_{0,j}(j \\ne 0)D0,j​(j​=0) 的值全置为 -inf 时，得出的解同时约束已选的物品总重恰好等于 WWW，因为此时所有“非完全填充”的中间状态都被移除了，合法解一定直接或间接地从 D0,0D_{0,0}D0,0​ 转移。 优化 Di,jD_{i,j}Di,j​ 由 Di−1,j−wi+viD_{i-1,j-w_i}+v_iDi−1,j−wi​​+vi​ 与 Di−1,jD_{i-1,j}Di−1,j​ 两个子问题递推而来，我们颠倒内层循环的顺序（jjj 从大到小迭代），并用一维数组D[W+1]代替二维数组D[N+1][W+1]，计算到 iii 时，就能使Dj−wiD_{j-w_i}Dj−wi​​ 始终持有 Di−1,j−wiD_{i-1,j-w_i}Di−1,j−wi​​ 的值，并把空间复杂度优化到 O(W)O(W)O(W)。此时还能改进循环下界，省去分支判断（j&lt;wij \\lt w_ij&lt;wi​ 时不修改数组即完成状态转移） int D[W + 1] = &#123;&#125;;for (int i = 0; i &lt; N; ++i) for (int j = W; j &gt;= w[i]; --j) D[j] = max(D[j], D[j - w[i]] + v[i]);return D[W]; 《背包问题九讲》1中还提到一个不太显然的优化，该问题中循环还有一个下界：W−∑k=i+1NwkW-\\sum_{k=i+1}^N w_kW−∑k=i+1N​wk​，则共同下界为两者中的更大值，即代码中 j 的循环条件改为： j &gt;= max(w[i], W - accumulate(w + i + 1, w + N, 0)) 笔者这样理解：已知结果为D[W]，最后一次做外层循环时，D[W]D[W]D[W]所需要先前的 D[W−wN]D[W-w_{N}]D[W−wN​]，而 D[W−wN]D[W-w_{N}]D[W−wN​] 又需要再先前的 D[W−wN−wN−1]D[W-w_{N}-w_{N-1}]D[W−wN​−wN−1​] …… 依此类推，则对于每一轮外层循环而言，其内层循环都可以给出下界 W−∑k=i+1NwkW-\\sum_{k=i+1}^N w_kW−∑k=i+1N​wk​。对应这样一种情况，到选择某个物品时，剩余价值量对于全选剩下的物品也足够的话，jjj 小于该剩余价值量情况不会被最终结果用到。 可以预先好计算下界值以避免二重循环内重复计算下界，但是聪明的现代编译器往往可以自行处理该优化。 该改进所能减少的计算次数因数据而异，画出折线图分析一下，横轴代表 iii，纵轴代表该 jjj，围成的矩形可以看作二维 DP 数组的每个元素。折线对应下界的值，蓝紫色区域对应引入另一个下界所省去的计算。 显然 W 越大，该下界越有效。对数据进行预处理也可以进一步优化下界，将原始数据按键值 wiw_iwi​ 以降序排序后，该下界更加有效。到这里，背包问题的解应该比较完美，但是时间复杂度依旧为 O(nW)O(nW)O(nW) 读者可以自行验证该结论，以空格分隔输入 wiw_iwi​ 的值，再输入 WWW 的值，刷新图表 w[i]:&nbsp&nbsp &nbsp&nbspW:&nbsp&nbsp &nbsp&nbsp &nbsp&nbsp 换个思路 因为算法的时间复杂度为 O(nW)O(nW)O(nW)，当物品的 www 有较大的取值范围，WWW 也是较大值的话，这个解的时间复杂度无法令人满意。如果 WWW 和 wiw_iwi​ 有最大公约数的话，在做动态规划之前除掉这个数可以大幅提高性能，如果最大公约数不存在，或者除掉后 WWW 依然是很大的值，那我们不妨换个思路。 设：Di,jD_{i,j}Di,j​为前 iii 种物品在总价值恰好为 jjj 的方案下能做到的最小体积，0&lt;j≤∑vi0 \\lt j \\le \\sum{v_i}0&lt;j≤∑vi​： Di,j=min{Di−1,j−vi+wi,Di−1,j}D_{i,j}= min \\{ D_{i-1,j-v_i}+w_i, D_{i-1,j} \\}Di,j​=min{Di−1,j−vi​​+wi​,Di−1,j​}原问题的最终解为 max⁡0&lt;j≤ DN,j≤W(j)\\displaystyle \\max_{0 \\lt j \\le \\,D_{N, j} \\le W}(j)0&lt;j≤DN,j​≤Wmax​(j)，该方法有点类似于 LIS 的优化方法。 int S = accumulate(v, v + N, 0);int D[S + 1]; // VLAmemset(D, 0x3f, S * 4);D[0] = 0;for (int i = 0; i &lt; N; ++i) for (int j = S; j &gt;= v[i]; --j) D[j] = min(D[j], D[j - v[i]] + w[i]);for (int i = S; i &gt;= 0; --i) if (D[i] &lt;= W) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; 易知此算法时间复杂度为 O(N∑vi)O(N\\sum{v_i})O(N∑vi​) 完全背包问题 Q：有 N 种物品，每种有无穷多个，每种物品有其对应的重量 wiw_iwi​ 和价值 viv_ivi​，求在总重量限制为 WWW 下取出最高价值的方案 解法 类比前文的思考方法，对第 iii 种物品有 kkk 种选择，其中最大值为当前约束下的最优决策，很容易写出以下递推公式和代码： Di,j=max⁡k=0⌊j/w[i]⌋(Di−1,j−k⋅wi+k⋅vi)D_{i,j}= \\displaystyle \\max_{k=0}^{ \\lfloor j/w[i] \\rfloor} (D_{i-1,j-k \\cdot w_i}+k \\cdot v_{i})Di,j​=k=0max⌊j/w[i]⌋​(Di−1,j−k⋅wi​​+k⋅vi​)int D[W + 1] = &#123;&#123;&#125;&#125;;for (int i = 0; i &lt; N; ++i) for (int j = W; j &gt;= w[i]; --j) for (int k = 1; k * w[i] &lt;= j; ++k) D[j] = max(D[j], D[i][j - k * w[i]] + k * v[i]);return D[W]; 该算法的时间复杂度是 O(nWWwi^)O(nW \\widehat{\\frac{W}{w_i}} )O(nWwi​W​​)，不是很让人满意，但是类比该方法容易给出一些变种背包问题的解2。 优化 《背包问题九讲》中直接将 0-1背包问题的空间优化代码的内层循环次序再次颠倒，即为完全背包问题的解，这里同时给出对应的状态转移方程和代码： Di,j=max⁡{Di,j−wi+vi,Di−1,j}D_{i,j}= \\max \\{D_{i,j-w_i}+v_i,D_{i-1,j} \\}Di,j​=max{Di,j−wi​​+vi​,Di−1,j​}int D[W + 1] = &#123;&#125;;for (int i = 0; i &lt; N; ++i) for (int j = w[i]; j &lt;= W; ++j) D[j] = max(D[j], D[j - w[i]] + v[i]);return D[W]; 这里的 DP 数组从小到大更新，除此之外和0-1背包完全相同，意味着Di,jD_{i,j}Di,j​ 从 Di,j−wi+viD_{i,j-w_i}+v_iDi,j−wi​​+vi​ 转移。这个解非常出乎意料，但是冷静下来，考虑 DDD 的意义，新问题规定物品可以重复选取，在加选第 iii 种物品时，应该从可能已选选取 iii 的情况转移。通过简单的方程变形能证明这个转移方程是正确的： Di,j=max⁡k=0⌊j/w[i]⌋(Di−1,j−k⋅wi+k⋅vi)D_{i,j}= \\displaystyle \\max_{k=0}^{ \\lfloor j/w[i] \\rfloor} (D_{i-1,j-k \\cdot w_i}+k \\cdot v_{i})Di,j​=k=0max⌊j/w[i]⌋​(Di−1,j−k⋅wi​​+k⋅vi​) =max⁡{max⁡k=1⌊j/w[i]⌋(Di−1,j−k⋅wi+k⋅vi),Di−1,j}~~~~~~~=\\max \\{ \\displaystyle \\max_{k=1}^{ \\lfloor j/w[i] \\rfloor} (D_{i-1,j-k \\cdot w_i}+k \\cdot v_{i}),D_{i-1,j} \\} =max{k=1max⌊j/w[i]⌋​(Di−1,j−k⋅wi​​+k⋅vi​),Di−1,j​} let k=t+1~~~~~~~let~~k=t+1 let k=t+1 =max⁡{max⁡t=0⌊j/w[i]⌋−1(Di−1,j−(t+1)⋅wi+(t+1)⋅vi),Di−1,j}~~~~~~~=\\max \\{ \\displaystyle \\max_{t=0}^{ \\lfloor j/w[i] \\rfloor-1} (D_{i-1,j-(t+1) \\cdot w_i}+(t+1) \\cdot v_{i}),D_{i-1,j} \\} =max{t=0max⌊j/w[i]⌋−1​(Di−1,j−(t+1)⋅wi​​+(t+1)⋅vi​),Di−1,j​} =max⁡{max⁡t=0⌊(j−wi)/w[i]⌋(Di−1,j−wi−t⋅wi+t⋅vi)+vi,Di−1,j}~~~~~~~=\\max \\{ \\displaystyle \\max_{t=0}^{ \\lfloor (j-w_i)/w[i] \\rfloor} (D_{i-1,j-w_i-t \\cdot w_i}+t \\cdot v_{i})+v_i,D_{i-1,j} \\} =max{t=0max⌊(j−wi​)/w[i]⌋​(Di−1,j−wi​−t⋅wi​​+t⋅vi​)+vi​,Di−1,j​} ∵Di,j−wi=max⁡t=0⌊(j−wi)/w[i]⌋(Di−1,j−wi−t⋅wi+t⋅vi)~~~~~~~\\because D_{i,j-w_i}=\\displaystyle \\max_{t=0}^{ \\lfloor (j-w_i)/w[i] \\rfloor}(D_{i-1,j-w_i-t \\cdot w_i}+t \\cdot v_{i}) ∵Di,j−wi​​=t=0max⌊(j−wi​)/w[i]⌋​(Di−1,j−wi​−t⋅wi​​+t⋅vi​) =max⁡{Di,j−wi+vi,Di−1,j}~~~~~~~= \\max \\{D_{i,j-w_i}+v_i,D_{i-1,j} \\} =max{Di,j−wi​​+vi​,Di−1,j​} 二维费用的背包问题 Q：有 N 件物品，每件物品有其对应的重量 wiw_iwi​、体积 uiu_iui​ 和价值 viv_ivi​，求在总重量限制为 WWW 且总体积限制为 UUU 下取出最高价值的方案 这个背包同时限制重量与体积，类比0-1背包问题的解，只需将状态转移方程加一维： Di,j,k=max⁡{Di−1,j−wi,k−ui+vi,Di−1,j,k}D_{i,j,k}= \\max \\{ D_{i-1,j-w_i,k-u_i}+v_i, D_{i-1,j,k} \\}Di,j,k​=max{Di−1,j−wi​,k−ui​​+vi​,Di−1,j,k​}回顾前面 LCS 一章，增加DP数组维度是处理更多约束的通用方法。 更一般的背包问题 《背包问题九讲》中提到了一个概念——“泛化物品”。有时候，物品的价值不是固定值，而可以看成是一个函数 f(w)f(w)f(w)，在一个费用 www 下该物品呈现出价值 f(w)f(w)f(w)，理解“泛化物品”的定义对解决问题可能有帮助。 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1，j2，……，jk，则所求的总和为：v[j1]*w[j1]+v[j2]*w[j2]+…+v[jk]*w[jk]。（其中*为乘号）请你帮助金明设计一个满足要求的购物单。 把主件和附件的组合看成一个物品组，物品组的价值是自变量 www 的函数，这里物品组就是前文所述的“泛化物品”。再把一个物品组看成是0-1背包问题中的一个物品，这样未解决的问题就转化为已解决的问题，类比分组背包问题，容易给出： Di,j=max⁡k∈Ki(Di−1,j−k+fi(k))D_{i,j}= \\displaystyle \\max_{k \\in K_i} (D_{i-1,j-k}+f_i(k))Di,j​=k∈Ki​max​(Di−1,j−k​+fi​(k))KiK_iKi​ 为物品组 iii 的价值函数的定义域，fi(k)f_i(k)fi​(k) 为一般物品 iii 恰好为 kkk 重下的最大价值。fi(k)f_{i}(k)fi​(k) 本身也是在物品组内用0-1背包的动态规划方法求得的。下面的代码可以用于提交OJ： int n, m;vector&lt;int&gt; W, V;struct pt &#123; int x; int fx;&#125;; // f(x)函数using f_t = vector&lt;pt&gt;; // 减少k迭代次数，优化时间复杂度struct tree &#123; int idx; vector&lt;tree&gt; child; void u(int g, int i) &#123; if (idx == g) child.push_back(tree&#123;i&#125;); else for (auto &amp;c : child) c.u(g, i); &#125; f_t solve() &#123; if (child.empty()) return f_t&#123;pt&#123;W[idx], V[idx]&#125;&#125;; vector&lt;int&gt; D(1); if (idx == 0) D.resize(m + 1); // 最外层背包不要求恰好装满 else D.resize(m + 1, 0xc0c0c0c0); // “内层背包”要求恰好装满 D[W[idx]] = V[idx]; for (int i = 0; i &lt; child.size(); ++i) &#123; auto f = child[i].solve(); for (int j = m; j &gt;= W[idx] + W[child[i].idx]; --j) for (pt k : f) &#123; if (k.x &gt; j) break; D[j] = max(D[j], D[j - k.x] + k.fx); &#125; &#125; f_t F; for (int i = 0; i &lt;= m; ++i) if (D[i] &gt; 0) F.push_back(pt&#123;i, D[i]&#125;); return F; &#125;&#125;;int main() &#123; scanf(\"%d %d\", &amp;m, &amp;n); m /= 10; W.resize(n + 1), V.resize(n + 1); // [0]为w=0,v=0的空元素,也是所有的元素的祖先 tree T&#123;0&#125;; for (int i = 1; i &lt;= n; ++i) &#123; int w, a, g; scanf(\"%d %d %d\", &amp;w, &amp;a, &amp;g); w = w / 10; W[i] = w, V[i] = a * w; T.u(g, i); &#125; f_t s = T.solve(); printf(\"%d\", s[s.size() - 1].fx * 10); return 0;&#125; 这里的解能适应更广泛的情况（更多附件数/多级附件），时空复杂度也已优化到最佳（大概）。类似的问题还有选课得学分，都是一类物件间有依赖关系的背包问题，解法都是树形DP。讨论这类花式DP问题远远超出了笔者的能力，在OI相关书籍上可以找到到更多这类复杂DP问题。 小结 和分治法的异同 《算法导论》中将 动态规划 和 分治法 作了比较： 动态规划 一般用于解决最优化问题，这种方法和 分治法 类似，也将问题分解为子问题，合并子问题的解得到原问题的解。但是 动态规划 和 分治法 就不同在 分治法 分治出的子问题是独立的，子问题之间没有交集；而 动态规划 两个问题可能有公共子问题。在分治法里，如果分解出相同的子问题，则问题会被重复求解； 动态规划 里这个子问题仅求解一次。 动态规划原理 《算法导论》15.3节中给出了易于被动态规划解决的问题的要素： 如果一个问题的最优解包含其子问题的最优解，我们就称此问题有 最优子结构 性质。 如果问题的递归算法会反复求解相同的子问题，我们就称此问题有 重叠子问题 性质。 实际上，不满足 最优子结构 性质的问题，动态规划一定是无能无力的，必须小心判断问题是否有 最优子结构 性质。3 构造状态转移方程的过程，《算法导论》称之为发掘 最优子结构 性质的过程，总结出了通用模式： 证明问题的最优解的第一个组成部分是做出一个选择 假定已经知道哪种选择才会得到最优解，不关心这种选择具体是如何得到的 确定选择会产生的子问题，尽量简单地刻画子问题空间 利用“剪切-粘贴”技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。利用反证法：假定子问题的解不是其自身的最优解，那么可以从原问题的解中“剪切”掉这些非最优的解，将最优解“粘贴”进去，从而得到原问题一个更优的解，这与最初的解是原问题的最优解矛盾。 可以比对前文中具体问题的解法体会这个通用模式 请读者注意《背包问题九讲》中此处（1.5节）可能有笔误。 ↩︎ 指多重背包问题和分组背包问题，详见《背包问题九讲》3节和6节 ↩︎ LIS 问题解决后，LDS（最长下降子序列）也同样容易，没错很多类似问题都这样，但是《算法导论》15.3节给出了一个反例。 ↩︎","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://moeologist.github.io/categories/Algorithm/"}],"tags":[]}]}