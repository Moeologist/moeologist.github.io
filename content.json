{"meta":{"title":"泛用型自宅机器人","subtitle":"想到哪写到哪","description":"后来我就念了两首诗","author":"ala","url":"https://moeologist.github.io","root":"/"},"pages":[{"title":"关于这里","date":"2021-07-19T17:53:59.481Z","updated":"2020-10-14T17:43:58.012Z","comments":true,"path":"about.html","permalink":"https://moeologist.github.io/about.html","excerpt":"","text":"这个博客主要由以下项目驱动: Hexo (框架) hexo-theme-hueman (主题) Pandoc (标记语言转换工具) \\(\\KaTeX\\) (轻量、快速的\\(\\TeX\\)公式渲染) Chart.js (图表渲染) Valine (评论系统) 推荐使用现代浏览器以获得最佳浏览效果，如果您对浏览器默认字体不满意，建议安装思源字体。 如果您有问题需要联系我: moeala@outlook.com"},{"title":"","date":"2021-07-19T17:53:59.481Z","updated":"2020-10-14T14:15:05.165Z","comments":true,"path":"js/demo.js","permalink":"https://moeologist.github.io/js/demo.js","excerpt":"","text":"try { let d3 = require(\"d3\"); } catch (error) { } let w = 512; let h = 300; let svg = d3.select(\"#demo\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); let markerdef = document.createElement(\"defs\") markerdef.innerHTML = '' svg.append(() => markerdef) let W = [2, 1, 3, 2]; let V = [3, 2, 4, 2]; let range = d3.range(W.length); let pos = range.flatMap(i => range.map(j => [i, j])) let size = 40 let g = svg.selectAll(\"g\") .data(pos) .enter() .append(\"g\"); let rect = g.append(\"rect\") rect.data(pos).enter() .attr(\"x\", d => (1 + d[0]) * size * 1.5) .attr(\"y\", d => (1 + d[1]) * size * 1.5) .attr(\"width\", size) .attr(\"height\", size) .attr(\"style\", \"fill: none; stroke: black; stroke-width: 1\")"},{"title":"","date":"2021-07-19T17:53:59.481Z","updated":"2020-10-14T17:22:43.150Z","comments":true,"path":"js/knapsack.js","permalink":"https://moeologist.github.io/js/knapsack.js","excerpt":"","text":"function createConfig(w, W) { let s = w.reduce((a, b) => a + b) let cw = w.map((sum => value => sum += value)(0)) // let cw = w.reduce((a, x, i) => [...a, x + (a[i - 1] || 0)], []) let ww = cw.map(x => x - s + W) let xw = ww.map((x, i) => x > w[i] ? x : w[i]) let lo = xw.map(x => x - 1) let dt = lo.map(x => W - x) return { type: 'bar', data: { labels: Array.from({ length: w.length }, (x, i) => i + 1).map(x => \"i = \" + x), datasets: [ { label: 'w[i]', backgroundColor: 'rgba(0, 177, 244, 1)', borderColor: 'rgba(0, 177, 244, 1)', data: w, borderWidth: 1, fill: false, type: 'line', xAxisID: 'nostackX', yAxisID: 'nostackY' }, { label: 'W - ∑', backgroundColor: 'rgba(54, 32, 255, 1)', borderColor: 'rgba(54, 32, 255, 1)', data: ww, borderWidth: 1, fill: false, type: 'line', xAxisID: 'nostackX', yAxisID: 'nostackY' }, { label: '下界改进', backgroundColor: 'rgba(54, 32, 255, 0.1)', borderColor: 'rgba(54, 32, 255, 0)', data: xw, borderWidth: 0, fill: 0, type: 'line', xAxisID: 'nostackX', yAxisID: 'nostackY' }, { label: '省去的计算', data: lo, borderWidth: 1, categoryPercentage: 1, barPercentage: 1 }, { label: '必需的计算', backgroundColor: 'rgba(88, 255, 47, 0.2)', borderColor: 'rgba(88, 255, 47, 0.2)', data: dt, borderWidth: 1, categoryPercentage: 1, barPercentage: 1 } ] }, options: { elements: { line: { tension: 0.000001 } }, scales: { xAxes: [ { stacked: true }, { display: false, stacked: false, id: 'nostackX', offset: true }, ], yAxes: [ { stacked: true, ticks: { min: 0, max: W, stepSize: 1, startAtZero: true } }, { display: false, stacked: false, ticks: { min: 0, max: W, stepSize: 1, startAtZero: true }, id: 'nostackY' } ] } } } } function createChart(divID, w, W) { let div = document.getElementById(divID) let canvas = document.createElement('canvas') div.appendChild(canvas) canvas.setAttribute('width', 400) canvas.setAttribute('height', 400) return new Chart(canvas.getContext('2d'), createConfig(w, W)) } window.onload = () => { let w = [2, 4, 2, 1, 3, 5, 2, 1, 5, 2, 1, 4, 1] let W = 13 let inputW = document.getElementById('input_W') let inputwi = document.getElementById('input_wi') inputW.value = W.toString() inputwi.value = w.reduce((a, b) => a + ' ' + b.toString()) chart = createChart('chart', w, W) function updateChart() { let w = inputwi.value.split(' ').map(x => parseInt(x)) let W = parseInt(inputW.value) let conf = createConfig(w, W) chart.data = conf.data chart.options = conf.options chart.update() } // inputW.onchange = updateChart // inputwi.onchange = updateChart document.getElementById('sort').onclick = () => { this.his = inputwi.value.split(' ').map(x => parseInt(x)) inputwi.value = this.his.slice().sort((a, b) => a - b).reverse().reduce((a, b) => a + ' ' + b.toString()) updateChart() } document.getElementById('refresh').onclick = () => { updateChart() } }"}],"posts":[{"title":"挂钩 Windows 的窗口消息处理函数","slug":"hook-wndproc","date":"2020-10-19T07:51:50.606Z","updated":"2020-11-21T17:13:34.091Z","comments":true,"path":"hook-wndproc/","link":"","permalink":"https://moeologist.github.io/hook-wndproc/","excerpt":"","text":"[src: Terraria] 动机 很多游戏在窗口失焦时会自动暂停，绝大多数情况下这没问题，也是玩家期待的行为，因为游戏大概率是全屏或最大化运行，没有玩家希望因为一个弹窗而导致角色死亡。但是如果游戏的输入操作都已经被自动化（如游戏内机制、脚本），或者游戏本身就并不需要太多输入，甚至双屏且大脑具有超线程的用户希望同时激活两个窗口。这个【自动暂停】显然是不利的，强制保持ACTIVE意味着进行其他工作必然会暂停该游戏。（Windows桌面环境只能一个窗口处于激活状态） 把行为类似这个游戏的程序称为【独占程序】，与之相对的，失焦不会暂停的程序（如浏览器、视频播放器）称为【非独占程序】。 解决方案 我们不能对操作系统下手，要解决这个问题，只能改变【独占程序】的行为。让【独占程序】不再独占需要对 消息处理函数 WndProc 下手，用 Win32 API写过窗口程序的朋友应该熟悉这个函数，该函数处理发送到窗口的消息。用户的所有操作都以操作系统桌面发消息的形式与程序交互，只要拦截了可能导致暂停的消息，那么就去掉了这个程序的“独占性”。 而对 WndProc 下手的做法就是一种挂钩（hooking），而处理拦截的代码，被称为钩子（hook）。 以下来自 wiki 条目： 钩子编程（hooking），也称作“挂钩”，是计算机程序设计术语，指通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）。 可以见得，并不是只有拦截 消息处理函数 的行为是挂钩。 而拦截了 WndProc 也不是只能处理这里【独占程序】的问题，与消息处理有关的其他问题也有可能通过这种方法解决（如自定义×按钮的行为、自定义组合键、分离输入） 细节 因为知道挂钩 Win32 API 已经有一些可以拿来主义的成品了1，如 EasyHook，顺着这个思路考虑。WndProc 函数是实现了窗口功能的程序员提供的，本身并不是 Win32 API，没法直接挂钩这个函数，只能挂钩任何与 WndProc 相关的 Win32 API 函数，如 CallWindowProc,DefWindowProc,RegisterClass，任何对这些函数的调用将被拦截，每次调用传入的 WndProc 参数都会被修改后传入原版 Win32 API 函数，这样就能完成任务。 这个方法很绕而且不干净，遇到了一些问题后我放弃了这个方法。 后来才知道 SetWindowLongPtr 能在运行时直接修改 WndProc，这时我才从圈子里转出来，挂钩消息处理函数并不需要挂钩 Win32 API。挂钩 WndProc 的代码大概像下面一样。 #include &lt;Windows.h&gt;WNDPROC originalWndProc = NULL;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; if (message == WM_NCACTIVATE) return 0; return CallWindowProc(originalWndProc, hWnd, message, wParam, lParam);&#125;void Hook() &#123; LONG_PTR lp = SetWindowLongPtr(hWindow, GWLP_WNDPROC, (LONG_PTR)WndProc); // Changes WNDPROC of the specified window originalWndProc = (WNDPROC)lp;&#125; 这里仅仅屏蔽了 WM_NCACTIVATE，根据实际情况可能还需要屏蔽更多消息。 实施 AutoHotkey 因为我使用了 AutoHotkey 进行了一些输入自动化和窗口管理功能，很自然地，我希望用 AutoHotkey 解决这个问题。遗憾的是，结果一番调查发现 AutoHotkey 无法实现此功能。 辅助工具 使用 Visual Studio 的自带工具 Spy++ 或者其他类似工具可以获取窗口信息，这对于实施本节的内容非常有帮助。 侵入式修改 Wiki 提到可以通过修改可执行程序来执行自己添加的代码，这要借助调试器找到 WndProc 的入口点并参考前文作出修改。注意：找入口点也可以直接借助 Spy++ 或其他类似工具。这涉及逆向的内容，虽然麻烦但是有效。 运行时修改 操作系统的事件钩子对这个问题没有帮助。不过我们可以直接向进程注入代码达到目的，或者进行 DLL注入，因为DLL注入用在这里很合适，所以这里给出被注入DLL本身的完整源代码： // Hook.dll#include &lt;Windows.h&gt;WNDPROC originalWndProc = NULL;// export is unnecessaryLRESULT __declspec(dllexport) CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; if (message == WM_NCACTIVATE) return 0; if (message == WM_ACTIVATEAPP &amp;&amp; wParam == FALSE) return 0; return CallWindowProc(originalWndProc, hWnd, message, wParam, lParam);&#125;BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam) &#123; DWORD pid = GetCurrentProcessId(); DWORD hWnd_pid = 0; GetWindowThreadProcessId(hWnd, &amp;hWnd_pid); if (pid == hWnd_pid) &#123; *(HWND *)lParam = hWnd; return FALSE; &#125; return TRUE;&#125;HWND GetCurrentHWND() &#123; HWND hWnd = 0; EnumWindows(EnumWindowsProc, (LPARAM)&amp;hWnd); return hWnd;&#125;void Hook() &#123; HWND hWindow = NULL; while (hWindow == NULL) &#123; hWindow = GetCurrentHWND(); // FindWindow is an alternative Sleep(100); &#125; LONG_PTR lp = SetWindowLongPtr(hWindow, GWLP_WNDPROC, (LONG_PTR)WndProc); // Changes WNDPROC of the specified window originalWndProc = (WNDPROC)lp;&#125;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) &#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: DisableThreadLibraryCalls(hModule); // This can reduce the size of the working set for some applications. CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Hook, hModule, NULL, NULL); // Run Hook in new thread case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 以上代码通过枚举所有窗口来获取当前进程对应的窗口句柄，也可以通过Spy++或其他类似工具取得窗口类名和标题，再借由 FindWindow 获取窗口句柄。 要做的工作还没有结束，还要将编译好 DLL 注入进程。 DLL注入 这节实在没什么可写的（毕竟作者也所知甚少），就直接把wiki放在在这里了，里面搜罗了很多方法。值得一提的是，除了注册表方法（全局），可实施性和通用性都比较好的方法应该就是 CreateRemoteThread 的代码注入方法了，也很适合用在这里。 我把 wiki 的示例代码增补成了一个命令行工具 Injector，和前文的 Hook DLL 源码放在了同一个 repo 里，非常粗糙的程序，小心取用。 实际上，要求程序加载指定 DLL，也可以不在运行时注入 DLL，通过修改 PE 文件的导入表（import table）解决问题2，这有一定的侵入性但某些情况下可能有优势。 尽管类似，但是挂钩 Win32 API 比本文的问题复杂得多↩︎ 参考 https://github.com/microsoft/Detours/wiki/OverviewPayloads↩︎","categories":[{"name":"Windows","slug":"Windows","permalink":"https://moeologist.github.io/categories/Windows/"}],"tags":[]},{"title":"Windows 字体折腾指南","slug":"win-font","date":"2020-10-14T14:15:05.162Z","updated":"2022-04-10T19:38:03.366Z","comments":true,"path":"win-font/","link":"","permalink":"https://moeologist.github.io/win-font/","excerpt":"改善Windows自身的字体渲染效果 众所周知，Windows的字体渲染的效果非常差，从隔壁系统过来的话常常会感到眼睛受到了侮辱。但是Windows10自带字体呈现效果似乎有了改观，启用ClearType，在高分屏下改观尤为明显，只可惜用户安装字体可能无法享受这个待遇，而Windows10自带的UI字体微软雅黑又胖又矮实在有点倒胃口，新版微软雅黑又迟迟不见踪影。","text":"改善Windows自身的字体渲染效果 众所周知，Windows的字体渲染的效果非常差，从隔壁系统过来的话常常会感到眼睛受到了侮辱。但是Windows10自带字体呈现效果似乎有了改观，启用ClearType，在高分屏下改观尤为明显，只可惜用户安装字体可能无法享受这个待遇，而Windows10自带的UI字体微软雅黑又胖又矮实在有点倒胃口，新版微软雅黑又迟迟不见踪影。 2160p对比1080p，2160p为200%UI缩放，1080p为nearest-neighbor插值upscaling到2x，字体为微软雅黑（Microsoft Yahei UI），字号为10pt 实际上，并非Windows对字体有偏见，而是进行了良好 hinting 字体在 Windows10 上面有较佳的渲染效果，而 ttfautohint 能自动生成 hinting 后的新字体。（由 FreeType 的 auto-hinting 模块处理） ttfautohint 的 Introduction 摘录： ttfautohint is a library written in C that takes a TrueType font as the input, removes its bytecode instructions (if any), and returns a new font where all glyphs are bytecode hinted using the information given by FreeType’s auto-hinting module. The idea is to provide the excellent quality of the auto-hinter on platforms that don’t use FreeType. 可以把喜爱的字体通过 ttfautohint 处理后安装到 Windows，至于如何使用这个软件，请大家读读文档自行摸索，因为 本文的作者也不会用 这个软件比较专业。 如果想要一个现成的中文字体，知乎大佬 Belleve 提供了 更纱黑体，基于思源黑体调整，很适合用来做Windows系统字体。 ​以下所有讨论都基于2160p/27″屏幕、200%UI缩放和Windows10 1909更新，更旧或更新的版本请自行验证。 替换字体 请小心使用以下内容，这些操作可能损坏你的系统，本文作者不承担任何责任: 安装了新字体后，浏览器可以注入样式表强制启用新字体，但桌面软件的UI还是该用啥用啥，除非能手动改（逐软件改也很麻烦），否则新字体还是不能用。如果希望把系统字体替换掉，可以尝试以下方法，这个方法需要安装AFDKO置换新字体的name表12为系统字体的name表，然后伪装成系统字体安装。 安装好AFDKO，克隆这个repo，里面包含了一些本文作者处理字体问题的脚本。 进入本地repo目录，其中包含将微软雅黑替换成更纱黑体的脚本 replace-msyh-by-sarasa.bat 和恢复微软雅黑的脚本 restore-msyh.bat 该脚本需要管理员权限，该脚本会自动注销系统，该脚本会从网络下载字体文件，该脚本需要执行两次！ 执行替换脚本 replace-msyh-by-sarasa.bat，该替换脚本会自动备份原版字体到脚本同级的 msyh-backup 下， 然后下载更纱黑体并自动生成伪装成雅黑的字体文件到 sarasa， 最后会删除字体的注册表项目并注销当前用户。 登录后再次执行该脚本，它会自动安装字体文件到系统目录并再次此注销。 再次登录，大功告成，效果如： 上面是微软雅黑，下面是更纱黑体，尽管摆脱了肥硕的微软雅黑，但是新字体部分字形表现不佳 restore-msyh.bat 的操作完全与上面相同，不同的是它将 msyh-backup 下的原版字体安装到系统。 如果需要替换其他字体，则需要自行修改脚本来适配。 品如的字体 macOS里预装了很多可爱的字体，如果你学会绕过系统的限制把它们提取了出来，就会遗憾地发现很多字体在Windows下不能用 网络流传有用sed替换苹方cmap表的attribute的方法，可惜这只对苹方和其它部分字体有用，sed替换命令没有处理name表，对cmap表的处理也过于草率。 上面的font-hack里还提供了一个名为macfonts.py的脚本，可以改善mac字体的兼容性，用法： python macfonts.py [*.ttf|*.otf|*.ttc|dir] 几个字体相关的注册表键值 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts] 映射已安装的字体文件 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] 字体的 fallback 表，很多软件喜欢用Tahoma作UI字体，这个字体没有中文码位，所有中文字形都通过此条目 fallback 到宋体上面（无衬线配衬线，嗯），把Tahoma键对应数据里的SIMSUN.TTC,SimSun替换成MSYH.TTC,Microsoft YaHei UI,128,96，用Tahoma显示字体的软件就不会显示成宋体了 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes] 字体的 substitute 表，没有安装、但键值存在于的字体会被键值对应的数据指代的字体冒充 替换Qt程序的字体引擎 在存在Qt动态库(Qt5Core.dll等等)的文件夹下面新建qt.conf，如果已经有文件则直接编辑该文件，添加以下行： [Platforms]WindowsArguments = fontengine=freetype 显式要求Qt程序使用freetype渲染字体。 替换系统字体渲染引擎 MacType 可以通过 Hook Windows API 替换 GDI 字体渲染引擎为 FreeType，规避了Windows提供的糟糕字体渲染，还能自定义许多渲染选项和字体热替换。这个软件本来是年久失修的，最近忽然又开始更新了，而且实验性的支持了 DirectWrite，尽管这个解决方案有诸多问题，还是建议大家尝试。 终极解决方案 如果追求完美的字体体验，还是 购买mac 使用Linux DE吧！ MS的字体文档： https://docs.microsoft.com/en-us/typography/opentype/spec/name↩︎ Apple的字体文档：https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html↩︎","categories":[{"name":"Windows","slug":"Windows","permalink":"https://moeologist.github.io/categories/Windows/"}],"tags":[]},{"title":"实现 constexpr 数学函数（元编程 / 改Clang源码）","slug":"clang-constexpr","date":"2020-10-07T21:44:59.817Z","updated":"2022-03-29T18:44:42.650Z","comments":true,"path":"clang-constexpr/","link":"","permalink":"https://moeologist.github.io/clang-constexpr/","excerpt":"","text":"动机 constexpr 是个好东西，到了C++20，它条件又放宽了很多，甚至动态分配内存都可以在编译时进行。然而，cmath(math.h)，里面的数学函数因为有副作用（errno或fenv异常）导致不能是constexpr。 解决方案 写个编译期数学库 想要在编译期做数学运算的的话可以自己写库，简单搜索一下Github，已经有了gcem,static_math 只要熟悉数值算法，不需要太多的元编程知识也能写出上述的编译期数学函数。可惜的是constexpr的限制意味着无法使用汇编，所以写出来的数学函数不可能与高度优化的数学库相提并论。这不是什么大问题，因为C++程序员（尤其是酷爱模板的程序员）绝不会介意编译时间多一点。最大的问题在于，constexpr一个好处就是编译时运行时都可用，除非肯定这些函数只在编译期用，因为运行期运算回退到低效的数学函数是任何使用C++的程序员都无法接受的。 GCC的扩展 __builtin_constant_p 或者 C++20 的 is_constant_evaluated 可以用于解决这个问题，探测求值语境选择合适算法。 举个例子，写一个开平方函数，先请出牛顿法：方程\\(f(x)=0\\)的根的近似值x可以由\\(x&#39;= x-\\frac{f(x)}{f&#39;(x)}\\)迭代求得，迭代次数越多精度越高，所以对于开平方函数sqrt(a)，构造\\(f(x)=x^2-a\\)求根即可。 constexpr double sqrt_slow(double a) &#123; double x = a; for (int i = 0; i &lt; 8; i++) x = (x + a / x) / 2; // 牛顿法迭代八次,因为constexpr的限制著名的卡马克魔法数也不能用 return x;&#125;constexpr double sqrt_adapter(double a) &#123; if (__builtin_is_constant_evaluated()) return sqrt_slow(a); else return sqrt(a);&#125;constexpr double sqrt_adapter_gcc_only(double a) &#123; // 至少需要GCC支持C++14的constexpr,不推荐使用 if (__builtin_constant_p(a)) // Clang的这个函数和GCC行为不同 https://reviews.llvm.org/D35190 return sqrt_slow(a); else return sqrt(a);&#125;int main() &#123; constexpr double q = sqrt_adapter(2.); double d; std::cin &gt;&gt; d; std::cout &lt;&lt; sqrt_adapter(d);&#125; 等新标准 p0533r0,p1383r0似乎没什么动静，且不说C++23，恐怕猴年马月也不一定有。 自己动手丰衣足食 尝试下面的代码对GCC来讲并没有什么压力： int main() &#123; constexpr double q = sqrt(2); // 仅GCC可用&#125; 搜索了一下又是GCC扩展，&lt;cmath&gt;里的函数支持了constexpr，这些浮点函数在有浮点错误时由编译器报出is not a constant expression错误，这似乎一定程度上就解决了问题（p1383r0里讨论了其他方面的潜在问题）。 要命的是Clang不支持这个扩展。想要只能自己动手，事后发现，Clang源码比想象中的要好改。 把repo拉下来，花上不少时间找到是这个文件clang/lib/AST/ExprConstant.cpp负责对常量表达式求值，于是照龙画蛇，找里面已经支持 constexpr 的 __builtin 函数观摩一番，然后把不支持的补上，浮点错误则让求值失败，就可以使内建函数支持 constexpr。这里有一个patch，可以参考里面的内容。 现在内建函数（如 __builtin_sqrt）是可以用在常量求值语境里了，但是如果希望&lt;cmath&gt;里的函数也可以，还要在libc++的&lt;cmath&gt;里受支持的函数签名加上constexpr，如果clang使用--stdlib=libstdc++则不需要此修改。 int main() &#123; constexpr double q = __builtin_sqrt(2); // 修改版Clang也能用 // constexpr double t = sqrt(2); // 还需要改libc++&#125; 如何构建 Clang 参照官方文档即可。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://moeologist.github.io/categories/C-C/"}],"tags":[]},{"title":"JavaScript 走马观花","slug":"var-vs-let","date":"2019-08-09T16:01:43.196Z","updated":"2020-11-21T16:53:43.118Z","comments":true,"path":"var-vs-let/","link":"","permalink":"https://moeologist.github.io/var-vs-let/","excerpt":"[src: 粗点心战争] 为了写博客被迫学了一点点JavaScript，把受的苦记下来，引用内容全来自MDN。","text":"[src: 粗点心战争] 为了写博客被迫学了一点点JavaScript，把受的苦记下来，引用内容全来自MDN。 自动分号插入 MDN上描述： 一些 JavaScript 语句必须用分号结束，所以会被自动分号补全 (ASI)影响： 空语句 let、const、变量声明 import、export、模块定义 表达式语句 debugger continue、break、throw return ECMAScript 规格提到自动分号补全的三个规则。 当出现一个不允许的行终止符或“}”时，会在其之前插入一个分号。 &#123; 1 2 &#125; 3 // 将会被 ASI 转换为 &#123; 1 2 ;&#125; 3; 当捕获到标识符输入流的结尾，并且无法将单个输入流转换为一个完整的程序时，将在结尾插入一个分号。 在下面这段中，由于在 b 和 ++ 之间出现了一个行终止符，所以 ++ 未被当成变量 b 的后置运算符。 a = b++c// 将被 ASI 转换为a = b;++c; 当语句中包含语法中的限制产品后跟一个行终止符的时候，将会在结尾插入一个分号。带“这里没有行终止符”规则的语句有： 后置运算符（++ 和 --） continue break return yield、yield* module returna + b// 将被 ASI 转换为return;a + b; 可能比较坑的只有 3，权衡一下还是不打分号对手指和键盘比较友好 Array.prototype.sort() 活见鬼的函数，默认将元素转为字符串操作： [1, 30, 4, 21, 100000].sort()// [1, 100000, 21, 30, 4] 对Number排序需要提供比较函数，比较函数是三路比较，和某语言新标准的飞船运算符一样： [1, 30, 4, 21, 100000].sort((a,b)=&gt;a-b)// [1, 4, 21, 30, 100000] 更难受的是排序算法没有提供不修改原序列的版本，简直对不起其它的一堆FP味的函数。 var, let, const var 看下面一个例子： var change = \"hello\";function f() &#123; var change = \"scram\";&#125;f();console.log(change); // 输出 scram 变量声明，无论发生在何处，都在执行任何代码之前进行处理。用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，或者对于声明在任何函数外的变量来说是全局。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。 重复的 var 定义将被忽视，但是初始化语句会执行。 赋值给未声明的变量 当赋值给未声明的变量, 则执行赋值后, 该变量会被隐式地创建为全局变量（它将成为全局对象的属性）。 声明和未声明变量之间的差异是： 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。 function x() &#123; y = 1; // 在严格模式（strict mode）下会抛出 ReferenceError 异常 var z = 2;&#125;x();console.log(y); // 打印 \"1\"console.log(z); // 抛出 ReferenceError: z 未在 x 外部声明 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。 console.log(a); // 抛出ReferenceError。console.log('still going...'); // 打印\"still going...\"。var a;console.log(a); // 打印\"undefined\"或\"\"（不同浏览器实现不同）。console.log('still going...'); // 打印\"still going...\"。 声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。 var a = 1;b = 2;delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。delete this.b;console.log(a, b); // 抛出ReferenceError。// 'b'属性已经被删除。 由于这三个差异，未能声明变量将很可能导致意想不到的结果。因此，建议始终声明变量，无论它们是在函数还是全局作用域内。 而且，在 ECMAScript 5 严格模式下，分配给未声明的变量会引发错误。 let 以及 const let 关键字就像在其他语言中所做的工作一样，不允许重复声明，也认真对待作用域： function varTest() &#123; var x = 1; &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; 位于函数或代码顶部的var声明会给全局对象新增属性, 而let不会。例如: var x = 'global';let y = 'global';console.log(this.x); // \"global\"console.log(this.y); // undefined 通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。 function do_something() &#123; console.log(bar); // undefined console.log(foo); // ReferenceError var bar = 1; let foo = 2;&#125; const 和 let 差不多但不接受重赋值操作。 Hoisting 另外一个值得一提的概念——变量提升（Hoisting），MDN上描述： 变量提升意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 前面已经给了变量的例子，对于函数也有： f(); // 没有问题function f() &#123; console.log(\"hello\");&#125; JSFuck 隐式转换 false =&gt; ![]true =&gt; !![]undefined =&gt; [][[]]NaN =&gt; +[![]]0 =&gt; +[]1 =&gt; +!+[]2 =&gt; !+[]+!+[]10 =&gt; [+!+[]]+[+[]]eval =&gt; [][\"filter\"][\"constructor\"](CODE)()window =&gt; [][\"filter\"][\"constructor\"](\"return this\")() 内容来自 JSFuck 比C++过分 彩蛋 Spin the globe，应该算Quine？该作者的主页还有更多被玩坏的JS。 eval(z='p=\"\"/* ,.oq#+ ,._, */;for(y in n=\"zw24l6k\\ 4e3t4jnt4qj24xh2 x/* =","categories":[{"name":"Web","slug":"Web","permalink":"https://moeologist.github.io/categories/Web/"}],"tags":[]},{"title":"动态规划——从入门到入门","slug":"knapsack","date":"2019-08-09T16:01:43.173Z","updated":"2022-03-18T18:41:31.200Z","comments":true,"path":"knapsack/","link":"","permalink":"https://moeologist.github.io/knapsack/","excerpt":"[src: xkcd] 前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！","text":"[src: xkcd] 前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！ 序列相关问题 这类问题通常写作最XX子序列的问题，实际上是是一类 最优子结构 问题，往往能用动态规划轻松解决。 最长上升子序列（LIS） 在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。注意最长递增子序列中的元素在原序列中不一定是连续的。 解法 值得一提的是 —— 这类问题一般只要求出最优解就可以。 设序列 \\(s\\) 的第 \\(i\\) 个元素为 \\(s_i\\)，以第 \\(i\\) 个元素结束的 LIS 为 \\(\\text{LIS}(i)\\)，\\(\\text{LIS}(i)\\) 长度为 \\(D_{i}\\)，那么 \\(D_{i}\\) 只可能等于 \\(D_j+1\\)（\\(0 \\le j \\lt i\\)），即 \\(\\text{LIS}(i)\\) 一定是某个 \\(\\text{LIS}(j)\\) 的尾部增添 \\(s_i\\) 构成的，约束 \\(s_j \\lt s_i\\) 并取所有 \\(\\text{LIS}(j)\\) 的最大值赋给 \\(D_{i}\\)。边界 \\(D_0=0\\)，从 \\(D_0\\) 转移意味着 \\(s_i\\) 不满足任何 \\(s_j \\lt s_i\\) ，则 \\(\\text{LIS}(j)\\) 是仅含有 \\(s_i\\) 的单元素序列。总的结果是 \\(\\displaystyle \\max_{0 \\lt i \\le n} (D_i)\\)。数学表达如下： \\[D_{i}= \\displaystyle \\max_{0 \\le j \\lt i, s_j \\lt s_i} (D_j)+1\\] 这类表达式被称作 状态转移方程。 #define n 9int s[n] = &#123;10, 11, 13, 9, 6, 5, 4, 7, 14&#125;;int D[n] = &#123;&#125;;for (int i = 0; i &lt; n; ++i) D[i] = 1;for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; i; ++j) if (s[j] &lt; s[i]) D[i] = max(D[i], D[j] + 1);return *max_element(D, D + n); 优化 上面解的时间复杂度是 \\(O(n^2)\\)，使用二分法的时间复杂度是 \\(O(n\\log(n))\\)，动态规划方法除了实现更容易似乎没有什么优势。实际上，换个思路，动态规划方法也能将时间复杂度降低到 \\(O(n\\log(n))\\)。 设序列 \\(s\\) 的 长度为 \\(k\\) 的最优上升子序列 为 \\(S^k\\)（什么是最优暂不讨论），\\(\\{S^1,S^2,S^3...,S^n\\}\\)的尾元素值构成数组 \\(D\\)，\\(D\\) 初始化为空数组，空数组 \\(D\\) 可以看成是严格单调增的。考察每个元素 \\(i\\)，如果 \\(D\\) 里面所有 \\(D_k\\) 都满足 \\(D_k \\lt s_i\\)，那么 \\(D\\) 数组尾部增添一个元素 \\(s_i\\)，LIS 长度增长 \\(1\\)；如果并非所有 \\(D_k\\) 都满足，那第一个恰不满足 \\(D_k \\lt s_i\\) 的 \\(D_k\\) 应该被更新为 \\(s_i\\)，意味着该 \\(D_k\\) 对应的 \\(S^k\\) 被更新为 \\(S^{k-1}\\) 加上后缀 \\(s_i\\)，这个序列被认为是比原序列更优的，因为该序列性质和原序列相同，并持有持有 更小 的尾元素，更小的尾巴更有利于序列增长（若原序列加上后缀 \\(s_i\\) 为上升序列，则新序列加上后缀 \\(s_i\\) 必定也是上升序列，反之不成立。） 思路非常绕但是实现很简单： int D[n] = &#123;&#125;;int len = 0;for (int i = 0; i &lt; n; ++i) &#123; int pos = lower_bound(D, D + len, s[i]) - D; // lower_bound返回有序数组D中第一个不小于s[i]的元素对应的迭代器 D[pos] = s[i]; len = max(len, pos + 1);&#125;return len; lower_bound 实现了二分查找，故总的时间复杂度是 \\(O(nlog(n))\\)，这个算法比朴素的二分查找简洁，运行效率也更高。 求解最优方案 前面说过这类问题一般只要求出最优解就可以，但是如果需要求最优解具体对应的方案，依然可以解决。还要注意除非题目有约束，否则最优的方案可能不止一个。回顾下前面的解，也许立即就能意识到：状态转移的过程就是取方案的过程，只要记录下状态转移的过程，最优解的方案就到手了。 为了代码好写，这里假设最优方案唯一： #define n 9int s[n] = &#123;0, 4, 9, 8, 7, 6, 5, 1, 2&#125;;int D[n] = &#123;&#125;;int S[n] = &#123;&#125;;for (int i = 0; i &lt; n; ++i) D[i] = 1;for (int i = 0; i &lt; n; ++i) S[i] = -1;for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; i; ++j) if (s[j] &lt; s[i] &amp;&amp; D[i] &lt; D[j] + 1) &#123; D[i] = D[j] + 1; S[i] = j; &#125;int M = max_element(D, D + n) - D;for (int i = M; i != -1; i = S[i]) printf(\"%d-&gt;\",S[i]);print(\"^\") 该算法回溯DP数组，以逆序输出解方案的序列。注意题设不能保证最优方案唯一时，本算法依然输出其中一个解（这个解特殊吗？）如果我们希望输出所有的解，那么需要用二维数组记录转移状态，而且回溯DP数组的算法也是 \\(O(n^2)\\) 的。后面的问题包括背包问题，都可以用此法给出解的方案，不再赘述。 最长公共子序列（LCS） 一个数值序列，如果分别是两个数值序列的子序列，且是所有符合此条件的序列中最长的，则称为已知序列的最长公共子序列。 解法 设两个序列分别为 \\(X,Y\\)，它们的 LCS 是 \\(\\text{LCS}(X,Y)\\)，\\(X^i\\) 是序列 \\(X\\) 长度为 \\(i\\) 的前缀，\\(Y^j\\) 是序列 \\(Y\\) 长度为 \\(j\\) 的前缀，\\(D_{i,j}\\) 是 \\(\\text{LCS}(X^i,Y^j)\\) 的长度。考察所有的前缀组合，当 \\(X^i\\) 和 \\(Y^j\\) 的尾元素相等（\\(X^i_i=Y^j_j\\)）时， \\(X^i\\) 和 \\(Y^j\\) 都是 \\(\\text{LCS}(X^i,Y^j)\\) 的尾元素，或者说 \\(\\text{LCS}(X^{i-1},Y^{j-1})\\) 尾部增添此元素构成 \\(\\text{LCS}(X^i,Y^j)\\)，则 \\(D_{i,j}=D_{i-1,j-1}+1\\)；如果 \\(X^i_i \\ne Y^j_j\\)，则 \\(D_{i,j}\\) 只能从 \\(D_{i-1,j},D_{i,j-1},D_{i-1,j-1}\\) 中的最大者转移，因为这些 \\(D\\) 分别对应的 \\(\\text{LCS}\\) 一定也是 \\(X^i\\) 和 \\(Y^j\\) 的公共子序列，三个 \\(D\\) 分别对应：仅 \\(X^i_i\\) 更新 LCS，仅 \\(Y^j_j\\) 更新 LCS，\\(X^i_i\\) 和 \\(Y^j_j\\) 都不能更新 LCS。边界 \\(D_{0,j}=0,D_{i,0}=0\\)： \\[same(x,y)= \\begin{cases} 0 &amp;\\text{if } s_i \\ne t_j \\\\ 1 &amp;\\text{if } s_i = t_j \\end{cases}\\] \\[D_{i,j}=\\max\\{ D_{i-1,j-1}+same(X_i, Y_j), D_{i-1,j}, D_{i,j-1} \\}\\] 实现细节 因为 \\(D_{i-1,j-1}\\) 小于 \\(D_{i-1,j-1}+same(X_i, Y_j)\\)，所以它没有办法影响状态转移，可以从 \\(\\max\\) 函数里去除，实际上，\\(D_{i-1,j-1}\\)一定最小的，\\(D_{i-1,j-1}+1\\) 一定是最大的。 char x[] = \"abcde\";char y[] = \"accabcdcced\";int n = strlen(x);int m = strlen(y);int D[2][m]; // VLA，在C++里属于GNU扩展功能，可以动态分配内存或用vectormemset(D, 0, 2 * m * 4);for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) D[(i + 1) % 2][j + 1] = max(D[i % 2][j] + int(x[i] == y[j])), D[i % 2][j + 1], D[(i + 1) % 2][j]);return D[n % 2][m]; 因为二维数组中，元素依赖的项目只有上一行 \\(i-1\\)，上面的算法交替使用 \\(2 \\times m\\) 数组的行来节省空间复杂度。这是一种通用的优化动态规划空间复杂度的方法。 更多个序列的 LCS 类比两个序列的情况，状态转移方程加一维，有： \\[D_{i,j,k}=\\max\\{ D_{i-1,j-1,k-1}+same(X_i, Y_j, Z_k), D_{i-1,j,k}, D_{i,j-1,k}, D_{i,j,k-1} \\}\\] 扩展阅读 LCS 实际上是很多实际问题的基础，比如著名的GNU diff。正因为如此，许许多多的科学工作者研究了这个问题，并给出了一些一定条件下的更优解。读者可以自行阅读wiki。 编辑距离 编辑距离可以看成 LCS 问题的扩展，因为比较实用且变种较多所以额外提及一下： 在计算语言学和计算机科学中，编辑距离是一种通过计算将一个字符串转换为另一个字符串所需的最小操作数来量化两个字符串（例如单词）彼此之间有多么不同的方式。 Levenshtein距离允许删除，插入和置换。 最长公共子序列（LCS）距离仅允许插入和删除。 Hamming距离仅允许替换，因此，它仅适用于具有相同的长度的字符串。 Damerau-Levenshtein距离允许插入，缺失，置换，和交换的两个相邻的字符。 Jaro距离只允许交换的两个相邻的字符。 拼写校正，DNA序列相似度分析，图片相似度等问题都是编辑距离的实际应用。这里给出最复杂的求Damerau-Levenshtein距离的状态转移方程，假设所有操作的费用都是1，思路类似 LCS，边界 \\(D_{0,0}=0\\)： \\[D_{i,j}=\\min \\begin{cases} D_{i-1,j}+1 &amp;\\text{if } i \\gt 0 \\\\ D_{i,j-1}+1 &amp;\\text{if } j \\gt 0 \\\\ D_{i-1,j-1} + same(s_i, t_j) &amp;\\text{if } i \\gt 0, j \\gt 0 \\\\ D_{i-2,j-2} + 1 &amp;\\text{if } i \\gt 1, j \\gt 1, s_i=t_{j-1}, s_{i-1}=t_j \\end{cases}\\] 尽管状态转移方程的项很多，但是代码很好写，注意如果费用不是1，甚至费用不是定值，方程稍加修改就能使用，实际编码时，可以额外初始化 \\(D_{0,j}=j, D_{i,0}=i\\) 来减少内层循环中的条件判断。 背包问题 背包问题是一类解法可以优化到伪多项式时间复杂度的NP-C问题，这类问题也常常被作为动态规划方法的入门问题被提及，最著名的教程就是《背包问题九讲》 0-1背包问题 Q：有 n 件物品，每件物品有其对应的重量 \\(w_i\\) 和价值 \\(v_i\\)，有一个总重量限制为 \\(W\\) 背包，求背包能装下的最大总价值 解法 设\\(D_{i,j}\\)为前 \\(i\\) 种物品在重量限制 \\(j\\) 下所能取出的最大值（限重 \\(j\\) 的背包所能装下的最大价值）。对第 \\(i\\) 种物品都可以有取与不取两种选择，假设前 \\(i-1\\) 种物品在重量限制 \\(j\\) 下能获得的最大价值为 \\(D_{i-1,j}\\)，如果选第 \\(i\\) 种物品，\\(D_{i,j}\\) 应为 \\(D_{i-1,j-w_i}+v_i\\)；不选的话，\\(D_{i,j}\\) 为 \\(D_{i-1,j}\\)。二者中更大者为问题的解： \\[D_{i,j}= \\max \\{ D_{i-1,j-w_i}+v_i, D_{i-1,j} \\}\\] 实现细节 容易得知DP数组的边界 \\(D_{0,0}=0\\)，最终解为 \\(D_{n,W}\\)，当 \\(j \\lt w_i\\) 时则意味着剩余重量已经不能支持取该物品了，可以直接置 \\(D_{i,j}=D_{i-1,j}\\)。该算法的时间复杂度与空间复杂度均为 \\(O(nW)\\)，相较之下，直接写成深搜时大量情况被重复计算，时间复杂度是 \\(O(2^n)\\)。 #define n 5#define W 7int w[n] = &#123;2,4,3,4,3&#125;;int v[n] = &#123;1,5,3,4,2&#125;;int D[n + 1][W + 1] = &#123;&#123;&#125;&#125;;for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt;= W; ++j) if (j &lt; w[i]) D[i + 1][j] = D[i][j]; else D[i + 1][j] = max(D[i][j], D[i][j - w[i]] + v[i]);return D[n][W]; 注意 \\(D\\) 下标 1 指代第一种物品，\\(w,v\\) 下标 0 指代第一种物品。 《背包问题九讲》提到一个初始化细节，将 \\(D_{0,j}(j \\ne 0)\\) 的值全置为 -inf 时，得出的解同时约束已选的物品总重恰好等于 \\(W\\)，因为此时所有“非完全填充”的中间状态都被移除了，合法解一定直接或间接地从 \\(D_{0,0}\\) 转移。 优化 \\(D_{i,j}\\) 由 \\(D_{i-1,j-w_i}+v_i\\) 与 \\(D_{i-1,j}\\) 两个子问题递推而来，我们颠倒内层循环的顺序（\\(j\\) 从大到小迭代），并用一维数组D[W+1]代替二维数组D[n+1][W+1]，计算到 \\(i\\) 时，就能使\\(D_{j-w_i}\\) 始终持有 \\(D_{i-1,j-w_i}\\) 的值，并把空间复杂度优化到 \\(O(W)\\)。此时还能改进循环下界，省去分支判断（\\(j \\lt w_i\\) 时不修改数组即完成状态转移） int D[W + 1] = &#123;&#125;;for (int i = 0; i &lt; n; ++i) for (int j = W; j &gt;= w[i]; --j) D[j] = max(D[j], D[j - w[i]] + v[i]);return D[W]; 《背包问题九讲》1中还提到一个不太显然的优化，该问题中循环还有一个下界：\\(W-\\sum_{k=i+1}^n w_k\\)，则共同下界为两者中的更大值，即代码中 j 的循环条件改为： j &gt;= max(w[i], W - accumulate(w + i + 1, w + n, 0)) 我这样理解：已知结果为 D[W]，最后一次做外层循环时，D[W] 所需要先前的 D[W-w[n]]，而 D[W-w[n]] 又需要再先前的 D[W-w[n]-w[n-1]] …… 依此类推，则对于每一轮外层循环而言，其内层循环都可以给出下界 \\(W-\\sum_{k=i+1}^n w_k\\)。对应这样一种情况，到选择某个物品时，剩余价值量对于全选剩下的物品也足够的话，\\(j\\) 小于该剩余价值量情况不会被最终结果用到。 可以预先好计算下界值以避免二重循环内重复计算下界，但是聪明的现代编译器往往可以自行处理该优化。 该改进所能减少的计算次数因数据而异，画个折线图分析一下，横轴代表 \\(i\\)，纵轴代表该 \\(j\\)，围成的矩形可以看作二维 DP 数组的每个元素。折线对应下界的值，蓝紫色区域对应引入另一个下界所省去的计算。 if (/MSIE|Trident/.test(window.navigator.userAgent)) { document.getElementById(\"chart\").innerHTML=\"不支持 Internet Explorer 的元素\" } 显然 W 相对越大，该下界越有效。对数据进行预处理也可以进一步优化下界，将原始数据按键值 \\(w_i\\) 以降序排序后，该下界更加有效。到这里，背包问题的解应该比较完美，但是时间复杂度依旧为 \\(O(nW)\\) 读者可以自行验证该结论，以空格分隔输入 \\(w_i\\) 的值，再输入 \\(W\\) 的值，刷新图表 w[i]:&nbsp&nbsp &nbsp&nbspW:&nbsp&nbsp &nbsp&nbsp &nbsp&nbsp 换个角度 因为算法的时间复杂度为 \\(O(nW)\\)，当物品的 \\(w\\) 有较大的取值范围，\\(W\\) 也是较大值的话，这个解的时间复杂度无法令人满意。如果 \\(W\\) 和 \\(w_i\\) 有最大公约数的话，在做动态规划之前除掉这个数可以大幅提高性能，如果最大公约数不存在，或者除掉后 \\(W\\) 依然是很大的值，那我们不妨换个思路。 设 \\(D_{i,j}\\) 为前 \\(i\\) 种物品在总价值恰好为 \\(j\\) 的方案下能做到的最小体积，\\(0 \\lt j \\le \\sum{v_i}\\)，转移方程： \\[D_{i,j}= min \\{ D_{i-1,j-v_i}+w_i, D_{i-1,j} \\}\\] 原问题的最终解为 \\(\\displaystyle \\max_{0 \\lt j \\le \\,D_{n, j} \\le W}(j)\\)，该方法思路有点类似于 LIS 的优化方法。 int S = accumulate(v, v + n, 0);int D[S + 1]; // VLAmemset(D, 0x3f, S * 4);D[0] = 0;for (int i = 0; i &lt; n; ++i) for (int j = S; j &gt;= v[i]; --j) D[j] = min(D[j], D[j - v[i]] + w[i]);for (int i = S; i &gt;= 0; --i) if (D[i] &lt;= W) &#123; cout &lt;&lt; i &lt;&lt; '\\n'; break; &#125; 易知此算法时间复杂度为 \\(O(n\\sum{v_i})\\) 完全背包问题 Q：有 n 种物品，每种有无穷多个，每种物品有其对应的重量 \\(w_i\\) 和价值 \\(v_i\\)，求在总重量限制为 \\(W\\) 下取出最高价值的方案 解法 类比前文的思考方法，对第 \\(i\\) 种物品有 \\(k\\) 种选择，其中最大值为当前约束下的最优决策，很容易写出以下递推公式和代码： \\[D_{i,j}= \\displaystyle \\max_{k=0}^{ \\lfloor j/w[i] \\rfloor} (D_{i-1,j-k \\cdot w_i}+k \\cdot v_{i})\\] int D[W + 1] = &#123;&#123;&#125;&#125;;for (int i = 0; i &lt; n; ++i) for (int j = W; j &gt;= w[i]; --j) for (int k = 1; k * w[i] &lt;= j; ++k) D[j] = max(D[j], D[i][j - k * w[i]] + k * v[i]);return D[W]; 该算法的时间复杂度是 \\(O(nW \\widehat{\\frac{W}{w_i}} )\\)，不是很让人满意，但是类比该方法容易给出一些变种背包问题的解。2 优化 《背包问题九讲》中直接将 0-1背包问题的空间优化代码的内层循环次序再次颠倒，即为完全背包问题的解，这里同时给出对应的状态转移方程和代码： \\[D_{i,j}= \\max \\{D_{i,j-w_i}+v_i,D_{i-1,j} \\}\\] int D[W + 1] = &#123;&#125;;for (int i = 0; i &lt; n; ++i) for (int j = w[i]; j &lt;= W; ++j) D[j] = max(D[j], D[j - w[i]] + v[i]);return D[W]; 这里的 DP 数组从小到大更新，除此之外和0-1背包完全相同，意味着\\(D_{i,j}\\) 从 \\(D_{i,j-w_i}+v_i\\) 转移。这个解非常出乎意料，但是冷静下来，考虑 \\(D\\) 的意义，新问题规定物品可以重复选取，在加选第 \\(i\\) 种物品时，应该从可能已选选取 \\(i\\) 的情况转移。通过简单的方程变形能证明这个转移方程是正确的： \\(D_{i,j}= \\displaystyle \\max_{k=0}^{ \\lfloor j/w[i] \\rfloor} (D_{i-1,j-k \\cdot w_i}+k \\cdot v_{i})\\) \\(~~~~~~~=\\max \\{ \\displaystyle \\max_{k=1}^{ \\lfloor j/w[i] \\rfloor} (D_{i-1,j-k \\cdot w_i}+k \\cdot v_{i}),D_{i-1,j} \\}\\) \\(~~~~~~~let~~k=t+1\\) \\(~~~~~~~=\\max \\{ \\displaystyle \\max_{t=0}^{ \\lfloor j/w[i] \\rfloor-1} (D_{i-1,j-(t+1) \\cdot w_i}+(t+1) \\cdot v_{i}),D_{i-1,j} \\}\\) \\(~~~~~~~=\\max \\{ \\displaystyle \\max_{t=0}^{ \\lfloor (j-w_i)/w[i] \\rfloor} (D_{i-1,j-w_i-t \\cdot w_i}+t \\cdot v_{i})+v_i,D_{i-1,j} \\}\\) \\(~~~~~~~\\because D_{i,j-w_i}=\\displaystyle \\max_{t=0}^{ \\lfloor (j-w_i)/w[i] \\rfloor}(D_{i-1,j-w_i-t \\cdot w_i}+t \\cdot v_{i})\\) \\(~~~~~~~= \\max \\{D_{i,j-w_i}+v_i,D_{i-1,j} \\}\\) 二维费用的背包问题 Q：有 n 件物品，每件物品有其对应的重量 \\(w_i\\)、体积 \\(u_i\\) 和价值 \\(v_i\\)，求在总重量限制为 \\(W\\) 且总体积限制为 \\(U\\) 下取出最高价值的方案 这个背包同时限制重量与体积，类比0-1背包问题的解，只需将状态转移方程加一维： \\[D_{i,j,k}= \\max \\{ D_{i-1,j-w_i,k-u_i}+v_i, D_{i-1,j,k} \\}\\] 回顾前面 LCS 一章，增加DP数组维度是处理更多约束的通用方法。 更一般的背包问题 《背包问题九讲》中提到了一个概念——“泛化物品”。有时候，物品的价值不是固定值，而可以看成是一个函数 \\(f(w)\\)，在一个费用 \\(w\\) 下该物品呈现出价值 \\(f(w)\\)，理解“泛化物品”的定义对解决问题可能有帮助。 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1，j2，……，jk，则所求的总和为：v[j1]*w[j1]+v[j2]*w[j2]+…+v[jk]*w[jk]。（其中*为乘号）请你帮助金明设计一个满足要求的购物单。 把主件和附件的组合看成一个物品组，物品组的价值是自变量 \\(w\\) 的函数，这里物品组就是前文所述的“泛化物品”。再把一个物品组看成是0-1背包问题中的一个物品，这样未解决的问题就转化为已解决的问题，类比分组背包问题，容易给出： \\[D_{i,j}= \\displaystyle \\max_{k \\in K_i} (D_{i-1,j-k}+f_i(k))\\] \\(K_i\\) 为物品组 \\(i\\) 的价值函数的定义域，\\(f_i(k)\\) 为一般物品 \\(i\\) 恰好为 \\(k\\) 重下的最大价值。\\(f_{i}(k)\\) 本身也是在物品组内用0-1背包的动态规划方法求得的。下面的代码可以用于提交OJ： int n, m;vector&lt;int&gt; W, V;struct pt &#123; int x; int fx;&#125;; // f(x)函数using f_t = vector&lt;pt&gt;; // 减少k迭代次数，优化时间复杂度struct tree &#123; int idx; vector&lt;tree&gt; child; void u(int g, int i) &#123; if (idx == g) child.push_back(tree&#123;i&#125;); else for (auto &amp;c : child) c.u(g, i); &#125; f_t solve() &#123; if (child.empty()) return f_t&#123;pt&#123;W[idx], V[idx]&#125;&#125;; vector&lt;int&gt; D(1); if (idx == 0) D.resize(m + 1); // 最外层背包不要求恰好装满 else D.resize(m + 1, 0xc0c0c0c0); // “内层背包”要求恰好装满 D[W[idx]] = V[idx]; for (int i = 0; i &lt; child.size(); ++i) &#123; auto f = child[i].solve(); for (int j = m; j &gt;= W[idx] + W[child[i].idx]; --j) for (pt k : f) &#123; if (k.x &gt; j) break; D[j] = max(D[j], D[j - k.x] + k.fx); &#125; &#125; f_t F; for (int i = 0; i &lt;= m; ++i) if (D[i] &gt; 0) F.push_back(pt&#123;i, D[i]&#125;); return F; &#125;&#125;;int main() &#123; scanf(\"%d %d\", &amp;m, &amp;n); m /= 10; W.resize(n + 1), V.resize(n + 1); // [0]为w=0,v=0的空元素,也是所有的元素的祖先 tree T&#123;0&#125;; for (int i = 1; i &lt;= n; ++i) &#123; int w, a, g; scanf(\"%d %d %d\", &amp;w, &amp;a, &amp;g); w = w / 10; W[i] = w, V[i] = a * w; T.u(g, i); &#125; f_t s = T.solve(); printf(\"%d\", s[s.size() - 1].fx * 10); return 0;&#125; 这里的解能适应更广泛的情况（更多附件数/多级附件），时空复杂度也已优化到最佳（大概）。类似的问题还有选课得学分，都是一类物件间有依赖关系的背包问题，解法都是树形DP。讨论这类花式DP问题远远超出了笔者的能力，在OI相关书籍上可以找到到更多这类复杂DP问题。 数论和组合数学相关 TODO 整数划分 TODO 小结 和分治法的异同 《算法导论》中将 动态规划 和 分治法 作了比较： 动态规划 一般用于解决最优化问题，这种方法和 分治法 类似，也将问题分解为子问题，合并子问题的解得到原问题的解。但是 动态规划 和 分治法 就不同在 分治法 分治出的子问题是独立的，子问题之间没有交集；而 动态规划 两个问题可能有公共子问题。在分治法里，如果分解出相同的子问题，则问题会被重复求解； 动态规划 里这个子问题仅求解一次。 动态规划原理 《算法导论》15.3节中给出了易于被动态规划解决的问题的要素： 如果一个问题的最优解包含其子问题的最优解，我们就称此问题有 最优子结构 性质。 如果问题的递归算法会反复求解相同的子问题，我们就称此问题有 重叠子问题 性质。 实际上，不满足 最优子结构 性质的问题，动态规划一定是无能无力的，必须小心判断问题是否有 最优子结构 性质。3 《算法导论》为发掘最优子结构性质的过程，总结出了通用模式： 证明问题的最优解的第一个组成部分是做出一个选择 假定已经知道哪种选择才会得到最优解，不关心这种选择具体是如何得到的 确定选择会产生的子问题，尽量简单地刻画子问题空间 利用“剪切-粘贴”技术和反证法证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。假定子问题的解不是其自身的最优解，那么可以从原问题的解中“剪切”掉这些非最优的解，将最优解“粘贴”进去，从而得到原问题一个更优的解，这与最初的解是原问题的最优解矛盾 可以比对前文中具体问题的解法体会这个通用模式。 请读者注意《背包问题九讲》中有关内容（1.5节）可能有笔误↩︎ 指多重背包问题和分组背包问题，详见《背包问题九讲》3节和6节↩︎ LIS 问题解决后，LDS（最长下降子序列）也同样容易，没错很多类似问题都这样，但是《算法导论》15.3节给出了一个反例↩︎","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://moeologist.github.io/categories/Algorithm/"}],"tags":[]}],"categories":[{"name":"Windows","slug":"Windows","permalink":"https://moeologist.github.io/categories/Windows/"},{"name":"C/C++","slug":"C-C","permalink":"https://moeologist.github.io/categories/C-C/"},{"name":"Web","slug":"Web","permalink":"https://moeologist.github.io/categories/Web/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://moeologist.github.io/categories/Algorithm/"}],"tags":[]}