<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">

    

    
    <title>动态规划——从入门到入门 | 泛用型自宅机器人</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content>
    
    <meta name="description" content="[src: xkcd] 前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！">
<meta name="keywords" content="编程">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划——从入门到入门">
<meta property="og:url" content="https://moeologist.github.io/knapsack/index.html">
<meta property="og:site_name" content="泛用型自宅机器人">
<meta property="og:description" content="[src: xkcd] 前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://moeologist.github.io/images/np_complete.png">
<meta property="og:updated_time" content="2020-12-13T17:21:26.611Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态规划——从入门到入门">
<meta name="twitter:description" content="[src: xkcd] 前言 动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！">
<meta name="twitter:image" content="https://moeologist.github.io/images/np_complete.png">
    

    

    
        <link rel="icon" href="data:image/x-icon;base64,R0lGODlhEAAQAPIAAAAAAHArAIw2AK1DANGGWP+fY////wAAACH5BAkUAAcAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAEAAQAAAD6nh3d3fnnHPOOeecc845x3Ecx3Ecx3EcxwEcAHAAx3Ecx3EcByAAgwFgAAAADofD4QAQDASDwWAwGAwAhwMAMBgMBoPBQCAYAA4HgGAgGAgCg4FgMBgMAIcDQDAQDAYDAgIAAgMDAAcHBwADAwEAAQAABQAAAwAHBwACAgMABQAGAAUABwAHBwcHAAICAAUFBgAFAAcHBwcHBwcAAAAEBQUFBQUABwcHBwcHBwcHAAQFBQUABwcHBwcHBwcHBwcAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcOHDhw4MCBAwcSAAAh+QQJFAAHACwAAAAAEAAQAAAD6nh3d3fnnHPOOeecc845x3Ecx3Ecx3EcxwEcAHAAx3Ecx3EcByAAgwFgAAAADofD4QAQDASDwWAwGAwAhwMAMBgMBoPBQCAYAA4HgGAgGAgCg4FgMBgMAIcDQDAQDAYDAgIAAgMDAAcHBwADAwEAAQAABQAAAwAHBwACAgMABQAGAAUABwAHBwcHAAICAAUFBgAFAAcHBwcHBwcAAAAEBQUFBQUABwcHBwcHBwcHAAQFBQUABwcHBwcHBwcHBwcAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcOHDhw4MCBAwcSAAAh+QQJFAAHACwAAAAAEAAQAAAD6nh3d3fnnHPOOeecc845x3Ecx3Ecx3EcxwEcAHAAx3Ecx3EcByAAgwFgAAAADofD4QAQDASDwWAwGAwAhwMAMBgMBoPBQCAYAA4HgGAgGAgCg4FgMBgMAIcDQDAQDAYDAgIAAgMDAAcHBwADAwEAAQAABQAAAwAHBwACAgMABQAGAAUABwAHBwcHAAICAAUFBgAFAAcHBwcHBwcAAAAEBQUFBQUABwcHBwcHBwcHAAQFBQUABwcHBwcHBwcHBwcAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcOHDhw4MCBAwcSAAAh+QQJCgAIACwAAAAAEAAQAIMAAAAFAgBwKwCMNgCtQwDRhlj/n2P///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE7xAhhBBCCCGEEEIIgiAIgiAIgiAIgiAIgiAIAiAAgAAIgiAIBAKBAAwABAKAAAAAEAgEAgEYEAYEAoFAIBAACAQAQCAQCAQCYTAgABAIwIAwIAwEBMKAQCAQAAgIAAMEAwQEBAMDAAMEBAAICAgABAQCAAIAAAYAAAQACAgAAwMEAAYAAQAGAAgACAgICAADAwAGBgcABgAICAgICAgIAAAABQYGBgYGAAgICAgICAgICAAFBgYGAAgICAgICAgICAgIAAAAAAgICAgICAgICAgICAgICAgICAgICBAgQIAAAQIECBAgQIAAAQIECCIAACH5BAkKAAcALAAAAAAQABAAggAAAAUCAHArAIw2AK1DANGGWP+fYwAAAAPqeHd3d+ecc84555xzzjnHcRzHcRzHcRzHARwAcADHcRzHcRwHMAAEAoAAAAAOh8PhABgQBgQCgUAgEACHAwBAIBAIBAJhMCAADgfAgDAgDAQEwoBAIBAAhwNgQBgQCAQDAwADBAQABwcHAAQEAgACAAAGAAAEAAcHAAMDBAAGAAYGBgAHAAcHBwcAAwMABgYBAQYABwcHBwcHBwAAAAUGBgYGBgAHBwcHBwcHBwcABQYGBgAHBwcHBwcHBwcHBwAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBw4cOHDgwIEDBxIAACH5BAkKAAgALAAAAAAQABAAgwAAAAUCAHArAIw2AK1DANGGWP+fY////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATvECGEEEIIIYQQQgiCIAiCIAiCIAiCIAiCIAgCIACAAAiCIAgEAoEADAAEAoAAAAAQCAQCARgQBgQCgUAgEAAIBABAIBAIBAJhMCAAEAjAgDAgDAQEwoBAIBAACAgAAwQDBAQEAwMAAwQEAAgICAAEBAIAAgAABgAABAAICAADAwQABgAAAAYACAAICAgIAAMDAAYGBwEGAAgICAgICAgAAAAFBgYGBgYACAgICAgICAgIAAUGBgYACAgICAgICAgICAgAAAAACAgICAgICAgICAgICAgICAgICAgIECBAgAABAgQIECBAgAABAgQIIgAAOw==">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <script src="//cdn.jsdelivr.net/npm/jquery@3.5.0/dist/jquery.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
    
    
    
    


</head>
</html>
<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo">泛用型自宅机器人</a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">想到哪写到哪</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/C-C/">C/C++</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Web/">Web</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Windows/">Windows</a></li></ul>
                                
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js" /></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Algorithm/">Algorithm</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-knapsack" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        动态规划——从入门到入门
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/knapsack/" class="article-date">
       <time datetime="2019-08-09T16:01:43.173Z" itemprop="datePublished">2019-08-10</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/knapsack/" class="article-date">
     <time datetime="2020-12-13T17:21:26.611Z" itemprop="dateModified">2020-12-14</time>
  </a>
</div>


                

                
                
   <span id="/knapsack/" class="leancloud-visitors" data-flag-title="动态规划——从入门到入门">
   <i class="fa fa-eye"></i>
   <span class="post-meta-item-text">阅读次数: </span>
   <i class="leancloud-visitors-count">1000000</i>
   </span>


                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <p><img src="/images/np_complete.png"> [src: <a href="https://xkcd.com/287/" target="_blank" rel="noopener">xkcd</a>]</p>
<h2 id="前言">前言</h2>
<p>动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！</p>
<a id="more"></a>
<h2 id="序列相关问题">序列相关问题</h2>
<p>这类问题通常写作<strong>最XX子序列的问题</strong>，实际上是是一类 <em>最优子结构</em> 问题，往往能用动态规划轻松解决。</p>
<h3 id="最长上升子序列lis">最长上升子序列（LIS）</h3>
<blockquote>
<p>在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。注意最长递增子序列中的元素在原序列中不一定是连续的。</p>
</blockquote>
<h4 id="解法">解法</h4>
<p>值得一提的是 —— 这类问题一般只要求出最优解就可以。</p>
<p>设序列 <span class="math inline">\(s\)</span> 的第 <span class="math inline">\(i\)</span> 个元素为 <span class="math inline">\(s_i\)</span>，以第 <span class="math inline">\(i\)</span> 个元素结束的 LIS 为 <span class="math inline">\(\text{LIS}(i)\)</span>，<span class="math inline">\(\text{LIS}(i)\)</span> 长度为 <span class="math inline">\(D_{i}\)</span>，那么 <span class="math inline">\(D_{i}\)</span> 只可能等于 <span class="math inline">\(D_j+1\)</span>（<span class="math inline">\(0 \le j \lt i\)</span>），即 <span class="math inline">\(\text{LIS}(i)\)</span> 一定是某个 <span class="math inline">\(\text{LIS}(j)\)</span> 的尾部增添 <span class="math inline">\(s_i\)</span> 构成的，约束 <span class="math inline">\(s_j \lt s_i\)</span> 并取所有 <span class="math inline">\(\text{LIS}(j)\)</span> 的最大值赋给 <span class="math inline">\(D_{i}\)</span>。边界 <span class="math inline">\(D_0=0\)</span>，从 <span class="math inline">\(D_0\)</span> 转移意味着 <span class="math inline">\(s_i\)</span> 不满足任何 <span class="math inline">\(s_j \lt s_i\)</span> ，则 <span class="math inline">\(\text{LIS}(j)\)</span> 是仅含有 <span class="math inline">\(s_i\)</span> 的单元素序列。总的结果是 <span class="math inline">\(\displaystyle \max_{0 \lt i \le n} (D_i)\)</span>。数学表达如下：</p>
<p><span class="math display">\[D_{i}= \displaystyle \max_{0 \le j \lt i, s_j \lt s_i} (D_j)+1\]</span></p>
<p>这类表达式被称作 <em>状态转移方程</em>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 9</span></span><br><span class="line"><span class="keyword">int</span> s[n] = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">14</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> D[n] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    D[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        <span class="keyword">if</span> (s[j] &lt; s[i])</span><br><span class="line">            D[i] = max(D[i], D[j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> *max_element(D, D + n);</span><br></pre></td></tr></table></figure>
<h4 id="优化">优化</h4>
<p>上面解的时间复杂度是 <span class="math inline">\(O(n^2)\)</span>，使用<a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="noopener">二分法</a>的时间复杂度是 <span class="math inline">\(O(n\log(n))\)</span>，动态规划方法除了实现更容易似乎没有什么优势。实际上，换个思路，动态规划方法也能将时间复杂度降低到 <span class="math inline">\(O(n\log(n))\)</span>。</p>
<p>设序列 <span class="math inline">\(s\)</span> 的 <em>长度为 <span class="math inline">\(k\)</span> 的最优上升子序列</em> 为 <span class="math inline">\(S^k\)</span>（什么是最优暂不讨论），<span class="math inline">\(\{S^1,S^2,S^3...,S^n\}\)</span>的尾元素值构成数组 <span class="math inline">\(D\)</span>，<span class="math inline">\(D\)</span> 初始化为空数组，空数组 <span class="math inline">\(D\)</span> 可以看成是严格单调增的。考察每个元素 <span class="math inline">\(i\)</span>，如果 <span class="math inline">\(D\)</span> 里面所有 <span class="math inline">\(D_k\)</span> 都满足 <span class="math inline">\(D_k \lt s_i\)</span>，那么 <span class="math inline">\(D\)</span> 数组尾部增添一个元素 <span class="math inline">\(s_i\)</span>，LIS 长度增长 <span class="math inline">\(1\)</span>；如果并非所有 <span class="math inline">\(D_k\)</span> 都满足，那第一个恰不满足 <span class="math inline">\(D_k \lt s_i\)</span> 的 <span class="math inline">\(D_k\)</span> 应该被更新为 <span class="math inline">\(s_i\)</span>，意味着该 <span class="math inline">\(D_k\)</span> 对应的 <span class="math inline">\(S^k\)</span> 被更新为 <span class="math inline">\(S^{k-1}\)</span> 加上后缀 <span class="math inline">\(s_i\)</span>，这个序列被认为是比原序列更优的，因为该序列性质和原序列相同，并持有持有 <strong>更小</strong> 的尾元素，更小的尾巴更有利于序列增长（若原序列加上后缀 <span class="math inline">\(s_i\)</span> 为上升序列，则新序列加上后缀 <span class="math inline">\(s_i\)</span> 必定也是上升序列，反之不成立。）</p>
<p>思路非常绕但是实现很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> D[n] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = lower_bound(D, D + len, s[i]) - D;</span><br><span class="line">    <span class="comment">// lower_bound返回有序数组D中第一个不小于s[i]的元素对应的迭代器</span></span><br><span class="line">    D[pos] = s[i];</span><br><span class="line">    len = max(len, pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br></pre></td></tr></table></figure>
<p>lower_bound 实现了二分查找，故总的时间复杂度是 <span class="math inline">\(O(nlog(n))\)</span>，这个算法比朴素的二分查找简洁，运行效率也更高。</p>
<h4 id="求解最优方案">求解最优方案</h4>
<p>前面说过这类问题一般只要求出最优解就可以，但是如果需要求最优解具体对应的方案，依然可以解决。还要注意除非题目有约束，否则最优的方案可能不止一个。回顾下前面的解，也许立即就能意识到：<strong>状态转移的过程就是取方案的过程</strong>，只要记录下状态转移的过程，最优解的方案就到手了。</p>
<p>为了代码好写，这里假设最优方案唯一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 9</span></span><br><span class="line"><span class="keyword">int</span> s[n] = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> D[n] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> S[n] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    D[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    S[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        <span class="keyword">if</span> (s[j] &lt; s[i] &amp;&amp; D[i] &lt; D[j] + <span class="number">1</span>) &#123;</span><br><span class="line">            D[i] = D[j] + <span class="number">1</span>;</span><br><span class="line">            S[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">int</span> M = max_element(D, D + n) - D;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i != <span class="number">-1</span>; i = S[i])</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>,S[i]);</span><br><span class="line">print(<span class="string">"^"</span>)</span><br></pre></td></tr></table></figure>
<p>该算法回溯DP数组，以逆序输出解方案的序列。注意题设不能保证最优方案唯一时，本算法依然输出其中一个解（这个解特殊吗？）如果我们希望输出所有的解，那么需要用二维数组记录转移状态，而且回溯DP数组的算法也是 <span class="math inline">\(O(n^2)\)</span> 的。后面的问题包括背包问题，都可以用此法给出解的方案，不再赘述。</p>
<h3 id="最长公共子序列lcs">最长公共子序列（LCS）</h3>
<blockquote>
<p>一个数值序列，如果分别是两个数值序列的子序列，且是所有符合此条件的序列中最长的，则称为已知序列的最长公共子序列。</p>
</blockquote>
<h4 id="解法-1">解法</h4>
<p>设两个序列分别为 <span class="math inline">\(X,Y\)</span>，它们的 LCS 是 <span class="math inline">\(\text{LCS}(X,Y)\)</span>，<span class="math inline">\(X^i\)</span> 是序列 <span class="math inline">\(X\)</span> 长度为 <span class="math inline">\(i\)</span> 的前缀，<span class="math inline">\(Y^j\)</span> 是序列 <span class="math inline">\(Y\)</span> 长度为 <span class="math inline">\(j\)</span> 的前缀，<span class="math inline">\(D_{i,j}\)</span> 是 <span class="math inline">\(\text{LCS}(X^i,Y^j)\)</span> 的长度。考察所有的前缀组合，当 <span class="math inline">\(X^i\)</span> 和 <span class="math inline">\(Y^j\)</span> 的尾元素相等（<span class="math inline">\(X^i_i=Y^j_j\)</span>）时， <span class="math inline">\(X^i\)</span> 和 <span class="math inline">\(Y^j\)</span> 都是 <span class="math inline">\(\text{LCS}(X^i,Y^j)\)</span> 的尾元素，或者说 <span class="math inline">\(\text{LCS}(X^{i-1},Y^{j-1})\)</span> 尾部增添此元素构成 <span class="math inline">\(\text{LCS}(X^i,Y^j)\)</span>，则 <span class="math inline">\(D_{i,j}=D_{i-1,j-1}+1\)</span>；如果 <span class="math inline">\(X^i_i \ne Y^j_j\)</span>，则 <span class="math inline">\(D_{i,j}\)</span> 只能从 <span class="math inline">\(D_{i-1,j},D_{i,j-1},D_{i-1,j-1}\)</span> 中的最大者转移，因为这些 <span class="math inline">\(D\)</span> 分别对应的 <span class="math inline">\(\text{LCS}\)</span> 一定也是 <span class="math inline">\(X^i\)</span> 和 <span class="math inline">\(Y^j\)</span> 的<strong>公共子序列</strong>，三个 <span class="math inline">\(D\)</span> 分别对应：仅 <span class="math inline">\(X^i_i\)</span> 更新 LCS，仅 <span class="math inline">\(Y^j_j\)</span> 更新 LCS，<span class="math inline">\(X^i_i\)</span> 和 <span class="math inline">\(Y^j_j\)</span> 都不能更新 LCS。边界 <span class="math inline">\(D_{0,j}=0,D_{i,0}=0\)</span>：</p>
<p><span class="math display">\[same(x,y)= 
\begin{cases}
    0 &amp;\text{if } s_i \ne t_j \\
    1 &amp;\text{if } s_i = t_j
\end{cases}\]</span></p>
<p><span class="math display">\[D_{i,j}=\max\{ D_{i-1,j-1}+same(X_i, Y_j), D_{i-1,j}, D_{i,j-1} \}\]</span></p>
<h4 id="实现细节">实现细节</h4>
<p>因为 <span class="math inline">\(D_{i-1,j-1}\)</span> 小于 <span class="math inline">\(D_{i-1,j-1}+same(X_i, Y_j)\)</span>，所以它没有办法影响状态转移，可以从 <span class="math inline">\(\max\)</span> 函数里去除，实际上，<span class="math inline">\(D_{i-1,j-1}\)</span>一定最小的，<span class="math inline">\(D_{i-1,j-1}+1\)</span> 一定是最大的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> x[] = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="keyword">char</span> y[] = <span class="string">"accabcdcced"</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(x);</span><br><span class="line"><span class="keyword">int</span> m = <span class="built_in">strlen</span>(y);</span><br><span class="line"><span class="keyword">int</span> D[<span class="number">2</span>][m]; <span class="comment">// VLA，在C++里属于GNU扩展功能，可以动态分配内存或用vector</span></span><br><span class="line"><span class="built_in">memset</span>(D, <span class="number">0</span>, <span class="number">2</span> * m * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        D[(i + <span class="number">1</span>) % <span class="number">2</span>][j + <span class="number">1</span>] = max(D[i % <span class="number">2</span>][j] + <span class="keyword">int</span>(x[i] == y[j])),</span><br><span class="line">                                    D[i % <span class="number">2</span>][j + <span class="number">1</span>],</span><br><span class="line">                                    D[(i + <span class="number">1</span>) % <span class="number">2</span>][j]);</span><br><span class="line"><span class="keyword">return</span> D[n % <span class="number">2</span>][m];</span><br></pre></td></tr></table></figure>
<p>因为二维数组中，元素依赖的项目只有上一行 <span class="math inline">\(i-1\)</span>，上面的算法交替使用 <span class="math inline">\(2 \times m\)</span> 数组的行来节省空间复杂度。这是一种通用的优化动态规划空间复杂度的方法。</p>
<h4 id="更多个序列的-lcs">更多个序列的 LCS</h4>
<p>类比两个序列的情况，状态转移方程加一维，有：</p>
<p><span class="math display">\[D_{i,j,k}=\max\{ D_{i-1,j-1,k-1}+same(X_i, Y_j, Z_k), D_{i-1,j,k}, D_{i,j-1,k}, D_{i,j,k-1} \}\]</span></p>
<h4 id="扩展阅读">扩展阅读</h4>
<p>LCS 实际上是很多实际问题的基础，比如著名的GNU diff。正因为如此，许许多多的科学工作者研究了这个问题，并给出了一些一定条件下的更优解。读者可以自行阅读<a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem" target="_blank" rel="noopener">wiki</a>。</p>
<h3 id="编辑距离">编辑距离</h3>
<p>编辑距离可以看成 LCS 问题的扩展，因为比较实用且变种较多所以额外提及一下：</p>
<blockquote>
<p>在计算语言学和计算机科学中，编辑距离是一种通过计算将一个字符串转换为另一个字符串所需的最小操作数来量化两个字符串（例如单词）彼此之间有多么不同的方式。</p>
<ul>
<li>Levenshtein距离允许删除，插入和置换。</li>
<li>最长公共子序列（LCS）距离仅允许插入和删除。</li>
<li>Hamming距离仅允许替换，因此，它仅适用于具有相同的长度的字符串。</li>
<li>Damerau-Levenshtein距离允许插入，缺失，置换，和交换的两个相邻的字符。</li>
<li>Jaro距离只允许交换的两个相邻的字符。</li>
</ul>
</blockquote>
<p>拼写校正，DNA序列相似度分析，图片相似度等问题都是编辑距离的实际应用。这里给出最复杂的求Damerau-Levenshtein距离的状态转移方程，假设所有操作的费用都是1，思路类似 LCS，边界 <span class="math inline">\(D_{0,0}=0\)</span>：</p>
<p><span class="math display">\[D_{i,j}=\min 
\begin{cases}
    D_{i-1,j}+1 &amp;\text{if } i \gt 0 \\
    D_{i,j-1}+1 &amp;\text{if } j \gt 0 \\
    D_{i-1,j-1} + same(s_i, t_j)  &amp;\text{if } i \gt 0, j \gt 0 \\
    D_{i-2,j-2} + 1  &amp;\text{if } i \gt 1, j \gt 1, s_i=t_{j-1}, s_{i-1}=t_j
\end{cases}\]</span></p>
<p>尽管状态转移方程的项很多，但是代码很好写，注意如果费用不是1，甚至费用不是定值，方程稍加修改就能使用，实际编码时，可以额外初始化 <span class="math inline">\(D_{0,j}=j, D_{i,0}=i\)</span> 来减少内层循环中的条件判断。</p>
<h2 id="背包问题">背包问题</h2>
<p>背包问题是一类解法可以优化到伪多项式时间复杂度的NP-C问题，这类问题也常常被作为动态规划方法的入门问题被提及，最著名的教程就是<a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">《背包问题九讲》</a></p>
<h3 id="背包问题-1">0-1背包问题</h3>
<blockquote>
<p>Q：有 n 件物品，每件物品有其对应的重量 <span class="math inline">\(w_i\)</span> 和价值 <span class="math inline">\(v_i\)</span>，有一个总重量限制为 <span class="math inline">\(W\)</span> 背包，求背包能装下的最大总价值</p>
</blockquote>
<h4 id="解法-2">解法</h4>
<p>设<span class="math inline">\(D_{i,j}\)</span>为前 <span class="math inline">\(i\)</span> 种物品在重量限制 <span class="math inline">\(j\)</span> 下所能取出的最大值（限重 <span class="math inline">\(j\)</span> 的背包所能装下的最大价值）。对第 <span class="math inline">\(i\)</span> 种物品都可以有取与不取两种选择，假设前 <span class="math inline">\(i-1\)</span> 种物品在重量限制 <span class="math inline">\(j\)</span> 下能获得的最大价值为 <span class="math inline">\(D_{i-1,j}\)</span>，如果选第 <span class="math inline">\(i\)</span> 种物品，<span class="math inline">\(D_{i,j}\)</span> 应为 <span class="math inline">\(D_{i-1,j-w_i}+v_i\)</span>；不选的话，<span class="math inline">\(D_{i,j}\)</span> 为 <span class="math inline">\(D_{i-1,j}\)</span>。二者中更大者为问题的解：</p>
<p><span class="math display">\[D_{i,j}= \max \{ D_{i-1,j-w_i}+v_i, D_{i-1,j} \}\]</span></p>
<h4 id="实现细节-1">实现细节</h4>
<p>容易得知DP数组的边界 <span class="math inline">\(D_{0,0}=0\)</span>，最终解为 <span class="math inline">\(D_{n,W}\)</span>，当 <span class="math inline">\(j \lt w_i\)</span> 时则意味着剩余重量已经不能支持取该物品了，可以直接置 <span class="math inline">\(D_{i,j}=D_{i-1,j}\)</span>。该算法的时间复杂度与空间复杂度均为 <span class="math inline">\(O(nW)\)</span>，相较之下，直接写成深搜时大量情况被重复计算，时间复杂度是 <span class="math inline">\(O(2^n)\)</span>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[n] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> v[n] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[n + <span class="number">1</span>][W + <span class="number">1</span>] = &#123;&#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; ++j)</span><br><span class="line">        <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">            D[i + <span class="number">1</span>][j] = D[i][j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D[i + <span class="number">1</span>][j] = max(D[i][j], D[i][j - w[i]] + v[i]);</span><br><span class="line"><span class="keyword">return</span> D[n][W];</span><br></pre></td></tr></table></figure>
<p>注意 <span class="math inline">\(D\)</span> 下标 <strong>1</strong> 指代第一种物品，<span class="math inline">\(w,v\)</span> 下标 <strong>0</strong> 指代第一种物品。</p>
<p>《背包问题九讲》提到一个初始化细节，将 <span class="math inline">\(D_{0,j}(j \ne 0)\)</span> 的值全置为 -inf 时，得出的解同时约束已选的物品总重恰好等于 <span class="math inline">\(W\)</span>，因为此时所有“非完全填充”的中间状态都被移除了，合法解一定直接或间接地从 <span class="math inline">\(D_{0,0}\)</span> 转移。</p>
<h4 id="优化-1">优化</h4>
<p><span class="math inline">\(D_{i,j}\)</span> 由 <span class="math inline">\(D_{i-1,j-w_i}+v_i\)</span> 与 <span class="math inline">\(D_{i-1,j}\)</span> 两个子问题递推而来，我们颠倒内层循环的顺序（<span class="math inline">\(j\)</span> 从大到小迭代），并用一维数组D[W+1]代替二维数组D[n+1][W+1]，计算到 <span class="math inline">\(i\)</span> 时，就能使<span class="math inline">\(D_{j-w_i}\)</span> 始终持有 <span class="math inline">\(D_{i-1,j-w_i}\)</span> 的值，并把空间复杂度优化到 <span class="math inline">\(O(W)\)</span>。此时还能改进循环下界，省去分支判断（<span class="math inline">\(j \lt w_i\)</span> 时不修改数组即完成状态转移）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> D[W + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i]; --j)</span><br><span class="line">        D[j] = max(D[j], D[j - w[i]] + v[i]);</span><br><span class="line"><span class="keyword">return</span> D[W];</span><br></pre></td></tr></table></figure>
<p>《背包问题九讲》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>中还提到一个不太显然的优化，该问题中循环还有一个下界：<span class="math inline">\(W-\sum_{k=i+1}^n w_k\)</span>，则共同下界为两者中的更大值，即代码中 j 的循环条件改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">j &gt;= max(w[i], W - accumulate(w + i + <span class="number">1</span>, w + n, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>我这样理解：已知结果为 D[W]，最后一次做外层循环时，D[W] 所需要先前的 D[W-w[n]]，而 D[W-w[n]] 又需要再先前的 D[W-w[n]-w[n-1]] …… 依此类推，则对于每一轮外层循环而言，其内层循环都可以给出下界 <span class="math inline">\(W-\sum_{k=i+1}^n w_k\)</span>。对应这样一种情况，到选择某个物品时，剩余价值量对于全选剩下的物品也足够的话，<span class="math inline">\(j\)</span> 小于该剩余价值量情况不会被最终结果用到。</p>
<p>可以预先好计算下界值以避免二重循环内重复计算下界，但是聪明的现代编译器往往可以自行处理该优化。</p>
<p>该改进所能减少的计算次数因数据而异，画个折线图分析一下，横轴代表 <span class="math inline">\(i\)</span>，纵轴代表该 <span class="math inline">\(j\)</span>，围成的矩形可以看作二维 DP 数组的每个元素。折线对应下界的值，蓝紫色区域对应引入另一个下界所省去的计算。</p>

<div id="chart"></div>
<script>
if (/MSIE|Trident/.test(window.navigator.userAgent)) {
    document.getElementById("chart").innerHTML="<b>不支持 Internet Explorer 的元素</b>"
}
</script>

<p>显然 W 相对越大，该下界越有效。对数据进行预处理也可以进一步优化下界，将原始数据按键值 <span class="math inline">\(w_i\)</span> 以降序排序后，该下界更加有效。到这里，背包问题的解应该比较完美，但是时间复杂度依旧为 <span class="math inline">\(O(nW)\)</span></p>
<p>读者可以自行验证该结论，以空格分隔输入 <span class="math inline">\(w_i\)</span> 的值，再输入 <span class="math inline">\(W\)</span> 的值，刷新图表</p>

<div id="interaction">
<i>w[i]:&nbsp&nbsp</i><input id="input_wi">
<i>&nbsp&nbspW:&nbsp&nbsp</i><input id="input_W">
<i>&nbsp&nbsp</i><input id="refresh" type="button" value="刷新">
<i>&nbsp&nbsp</i><input id="sort" type="button" value="排序">
</div>
<link type="text/css" rel="stylesheet" href="//cdn.jsdelivr.net/npm/chart.js@2.9.2/dist/Chart.min.css">
<script src="//cdn.jsdelivr.net/npm/chart.js@2.9.2/dist/Chart.min.js"></script>
<script src="/js/knapsack.js"></script>

<h4 id="换个角度">换个角度</h4>
<p>因为算法的时间复杂度为 <span class="math inline">\(O(nW)\)</span>，当物品的 <span class="math inline">\(w\)</span> 有较大的取值范围，<span class="math inline">\(W\)</span> 也是较大值的话，这个解的时间复杂度无法令人满意。如果 <span class="math inline">\(W\)</span> 和 <span class="math inline">\(w_i\)</span> 有最大公约数的话，在做动态规划之前除掉这个数可以大幅提高性能，如果最大公约数不存在，或者除掉后 <span class="math inline">\(W\)</span> 依然是很大的值，那我们不妨换个思路。</p>
<p>设 <span class="math inline">\(D_{i,j}\)</span> 为前 <span class="math inline">\(i\)</span> 种物品在总价值恰好为 <span class="math inline">\(j\)</span> 的方案下能做到的最小体积，<span class="math inline">\(0 \lt j \le \sum{v_i}\)</span>，转移方程：</p>
<p><span class="math display">\[D_{i,j}= min \{ D_{i-1,j-v_i}+w_i, D_{i-1,j} \}\]</span></p>
<p>原问题的最终解为 <span class="math inline">\(\displaystyle \max_{0 \lt j \le \,D_{n, j} \le W}(j)\)</span>，该方法思路有点类似于 LIS 的优化方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> S = accumulate(v, v + n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> D[S + <span class="number">1</span>]; <span class="comment">// VLA</span></span><br><span class="line"><span class="built_in">memset</span>(D, <span class="number">0x3f</span>, S * <span class="number">4</span>);</span><br><span class="line">D[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = S; j &gt;= v[i]; --j)</span><br><span class="line">        D[j] = min(D[j], D[j - v[i]] + w[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = S; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (D[i] &lt;= W) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>易知此算法时间复杂度为 <span class="math inline">\(O(n\sum{v_i})\)</span></p>
<h3 id="完全背包问题">完全背包问题</h3>
<blockquote>
<p>Q：有 n 种物品，每种有无穷多个，每种物品有其对应的重量 <span class="math inline">\(w_i\)</span> 和价值 <span class="math inline">\(v_i\)</span>，求在总重量限制为 <span class="math inline">\(W\)</span> 下取出最高价值的方案</p>
</blockquote>
<h4 id="解法-3">解法</h4>
<p>类比前文的思考方法，对第 <span class="math inline">\(i\)</span> 种物品有 <span class="math inline">\(k\)</span> 种选择，其中最大值为当前约束下的最优决策，很容易写出以下递推公式和代码：</p>
<p><span class="math display">\[D_{i,j}= \displaystyle \max_{k=0}^{ \lfloor j/w[i] \rfloor} (D_{i-1,j-k \cdot w_i}+k \cdot v_{i})\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> D[W + <span class="number">1</span>] = &#123;&#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i]; --j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * w[i] &lt;= j; ++k)</span><br><span class="line">            D[j] = max(D[j], D[i][j - k * w[i]] + k * v[i]);</span><br><span class="line"><span class="keyword">return</span> D[W];</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度是 <span class="math inline">\(O(nW \widehat{\frac{W}{w_i}} )\)</span>，不是很让人满意，但是类比该方法容易给出一些变种背包问题的解。<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h4 id="优化-2">优化</h4>
<p>《背包问题九讲》中直接将 0-1背包问题的空间优化代码的内层循环次序再次颠倒，即为完全背包问题的解，这里同时给出对应的状态转移方程和代码：</p>
<p><span class="math display">\[D_{i,j}= \max \{D_{i,j-w_i}+v_i,D_{i-1,j} \}\]</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> D[W + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= W; ++j)</span><br><span class="line">        D[j] = max(D[j], D[j - w[i]] + v[i]);</span><br><span class="line"><span class="keyword">return</span> D[W];</span><br></pre></td></tr></table></figure>
<p>这里的 DP 数组<strong>从小到大</strong>更新，除此之外和0-1背包完全相同，意味着<span class="math inline">\(D_{i,j}\)</span> 从 <span class="math inline">\(D_{i,j-w_i}+v_i\)</span> 转移。这个解非常出乎意料，但是冷静下来，考虑 <span class="math inline">\(D\)</span> 的意义，新问题规定物品可以重复选取，在加选第 <span class="math inline">\(i\)</span> 种物品时，应该从<strong>可能已选选取</strong> <span class="math inline">\(i\)</span> 的情况转移。通过简单的方程变形能证明这个转移方程是正确的：</p>
<p><span class="math inline">\(D_{i,j}= \displaystyle \max_{k=0}^{ \lfloor j/w[i] \rfloor} (D_{i-1,j-k \cdot w_i}+k \cdot v_{i})\)</span></p>
<p><span class="math inline">\(~~~~~~~=\max \{ \displaystyle \max_{k=1}^{ \lfloor j/w[i] \rfloor} (D_{i-1,j-k \cdot w_i}+k \cdot v_{i}),D_{i-1,j} \}\)</span></p>
<p><span class="math inline">\(~~~~~~~let~~k=t+1\)</span></p>
<p><span class="math inline">\(~~~~~~~=\max \{ \displaystyle \max_{t=0}^{ \lfloor j/w[i] \rfloor-1} (D_{i-1,j-(t+1) \cdot w_i}+(t+1) \cdot v_{i}),D_{i-1,j} \}\)</span></p>
<p><span class="math inline">\(~~~~~~~=\max \{ \displaystyle \max_{t=0}^{ \lfloor (j-w_i)/w[i] \rfloor} (D_{i-1,j-w_i-t \cdot w_i}+t \cdot v_{i})+v_i,D_{i-1,j} \}\)</span></p>
<p><span class="math inline">\(~~~~~~~\because D_{i,j-w_i}=\displaystyle \max_{t=0}^{ \lfloor (j-w_i)/w[i] \rfloor}(D_{i-1,j-w_i-t \cdot w_i}+t \cdot v_{i})\)</span></p>
<p><span class="math inline">\(~~~~~~~= \max \{D_{i,j-w_i}+v_i,D_{i-1,j} \}\)</span></p>
<h3 id="二维费用的背包问题">二维费用的背包问题</h3>
<blockquote>
<p>Q：有 n 件物品，每件物品有其对应的重量 <span class="math inline">\(w_i\)</span>、体积 <span class="math inline">\(u_i\)</span> 和价值 <span class="math inline">\(v_i\)</span>，求在总重量限制为 <span class="math inline">\(W\)</span> 且总体积限制为 <span class="math inline">\(U\)</span> 下取出最高价值的方案</p>
</blockquote>
<p>这个背包同时限制重量与体积，类比0-1背包问题的解，只需将状态转移方程加一维：</p>
<p><span class="math display">\[D_{i,j,k}= \max \{ D_{i-1,j-w_i,k-u_i}+v_i, D_{i-1,j,k} \}\]</span></p>
<p>回顾前面 LCS 一章，增加DP数组维度是处理更多约束的通用方法。</p>
<h3 id="更一般的背包问题">更一般的背包问题</h3>
<p>《背包问题九讲》中提到了一个概念——“泛化物品”。有时候，物品的价值不是固定值，而可以看成是一个函数 <span class="math inline">\(f(w)\)</span>，在一个费用 <span class="math inline">\(w\)</span> 下该物品呈现出价值 <span class="math inline">\(f(w)\)</span>，理解“泛化物品”的定义对解决问题可能有帮助。</p>
<blockquote>
<p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>主件</th>
<th>附件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>电脑</td>
<td>打印机，扫描仪</td>
</tr>
<tr class="even">
<td>书柜</td>
<td>图书</td>
</tr>
<tr class="odd">
<td>书桌</td>
<td>台灯，文具</td>
</tr>
<tr class="even">
<td>工作椅</td>
<td>无</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1，j2，……，jk，则所求的总和为：v[j1]*w[j1]+v[j2]*w[j2]+…+v[jk]*w[jk]。（其中*为乘号）请你帮助金明设计一个满足要求的购物单。</p>
</blockquote>
<p>把主件和附件的组合看成一个物品组，物品组的价值是自变量 <span class="math inline">\(w\)</span> 的函数，这里物品组就是前文所述的“泛化物品”。再把一个物品组看成是0-1背包问题中的一个物品，这样未解决的问题就转化为已解决的问题，类比分组背包问题，容易给出：</p>
<p><span class="math display">\[D_{i,j}= \displaystyle \max_{k \in K_i} (D_{i-1,j-k}+f_i(k))\]</span></p>
<p><span class="math inline">\(K_i\)</span> 为物品组 <span class="math inline">\(i\)</span> 的价值函数的定义域，<span class="math inline">\(f_i(k)\)</span> 为一般物品 <span class="math inline">\(i\)</span> 恰好为 <span class="math inline">\(k\)</span> 重下的最大价值。<span class="math inline">\(f_{i}(k)\)</span> 本身也是在物品组内用0-1背包的动态规划方法求得的。下面的代码可以用于提交OJ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; W, V;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> fx;</span><br><span class="line">&#125;; <span class="comment">// f(x)函数</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">f_t</span> = <span class="built_in">vector</span>&lt;pt&gt;; <span class="comment">// 减少k迭代次数，优化时间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;tree&gt; child;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">(<span class="keyword">int</span> g, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == g)</span><br><span class="line">            child.push_back(tree&#123;i&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : child)</span><br><span class="line">                c.u(g, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">f_t</span> solve() &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">f_t</span>&#123;pt&#123;W[idx], V[idx]&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; D(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>)</span><br><span class="line">            D.resize(m + <span class="number">1</span>); <span class="comment">// 最外层背包不要求恰好装满</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D.resize(m + <span class="number">1</span>, <span class="number">0xc0c0c0c0</span>); <span class="comment">// “内层背包”要求恰好装满</span></span><br><span class="line">        D[W[idx]] = V[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; child.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = child[i].solve();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= W[idx] + W[child[i].idx]; --j)</span><br><span class="line">                <span class="keyword">for</span> (pt k : f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k.x &gt; j)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    D[j] = max(D[j], D[j - k.x] + k.fx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">f_t</span> F;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (D[i] &gt; <span class="number">0</span>)</span><br><span class="line">                F.push_back(pt&#123;i, D[i]&#125;);</span><br><span class="line">        <span class="keyword">return</span> F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    m /= <span class="number">10</span>;</span><br><span class="line">    W.resize(n + <span class="number">1</span>), V.resize(n + <span class="number">1</span>); <span class="comment">// [0]为w=0,v=0的空元素,也是所有的元素的祖先</span></span><br><span class="line">    tree T&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w, a, g;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;w, &amp;a, &amp;g);</span><br><span class="line">        w = w / <span class="number">10</span>;</span><br><span class="line">        W[i] = w, V[i] = a * w;</span><br><span class="line">        T.u(g, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">f_t</span> s = T.solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, s[s.size() - <span class="number">1</span>].fx * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的解能适应更广泛的情况（更多附件数/多级附件），时空复杂度也已优化到最佳（大概）。类似的问题还有选课得学分，都是一类物件间有依赖关系的背包问题，解法都是树形DP。讨论这类花式DP问题远远超出了笔者的能力，在OI相关书籍上可以找到到更多这类复杂DP问题。</p>
<h2 id="数论和组合数学相关">数论和组合数学相关</h2>
<p>TODO</p>
<h3 id="整数划分">整数划分</h3>
<p>TODO</p>
<h2 id="小结">小结</h2>
<h3 id="和分治法的异同">和分治法的异同</h3>
<p>《算法导论》中将 <em>动态规划</em> 和 <em>分治法</em> 作了比较： <em>动态规划</em> 一般用于解决<strong>最优化问题</strong>，这种方法和 <em>分治法</em> 类似，也将问题分解为子问题，合并子问题的解得到原问题的解。但是 <em>动态规划</em> 和 <em>分治法</em> 就不同在 <em>分治法</em> 分治出的子问题是独立的，子问题之间没有交集；而 <em>动态规划</em> 两个问题可能有公共子问题。在分治法里，如果分解出相同的子问题，则问题会被重复求解； <em>动态规划</em> 里这个子问题仅求解一次。</p>
<h3 id="动态规划原理">动态规划原理</h3>
<p>《算法导论》15.3节中给出了易于被动态规划解决的问题的要素：</p>
<ul>
<li>如果一个问题的最优解包含其子问题的最优解，我们就称此问题有 <em>最优子结构</em> 性质。</li>
<li>如果问题的递归算法会反复求解相同的子问题，我们就称此问题有 <em>重叠子问题</em> 性质。</li>
</ul>
<p>实际上，不满足 <em>最优子结构</em> 性质的问题，动态规划一定是无能无力的，必须小心判断问题是否有 <em>最优子结构</em> 性质。<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>《算法导论》为发掘最优子结构性质的过程，总结出了通用模式：</p>
<ol type="1">
<li>证明问题的最优解的第一个组成部分是做出一个选择</li>
<li>假定已经知道哪种选择才会得到最优解，不关心这种选择具体是如何得到的</li>
<li>确定选择会产生的子问题，尽量简单地刻画子问题空间</li>
<li>利用“剪切-粘贴”技术和反证法证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。<strong>假定子问题的解不是其自身的最优解，那么可以从原问题的解中“剪切”掉这些非最优的解，将最优解“粘贴”进去，从而得到原问题一个更优的解，这与最初的解是原问题的最优解矛盾</strong></li>
</ol>
<p>可以比对前文中具体问题的解法体会这个通用模式。</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>请读者注意<a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">《背包问题九讲》</a>中有关内容（1.5节）可能有笔误<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>指<strong>多重背包问题</strong>和<strong>分组背包问题</strong>，详见<a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">《背包问题九讲》</a>3节和6节<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>LIS 问题解决后，LDS（最长下降子序列）也同样容易，没错很多类似问题都这样，但是《算法导论》15.3节给出了一个反例<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

        </div>
        <footer class="article-footer">
            



    <a data-url="https://moeologist.github.io/knapsack/" data-id="ckx29nfpv0004k8g5avxu8whh" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "ala"
        },
        "headline": "动态规划——从入门到入门",
        "image": "https://moeologist.github.io/images/np_complete.png",
        "keywords": "",
        "genre": "Algorithm",
        "datePublished": "2019-08-10",
        "dateCreated": "2019-08-10",
        "dateModified": "2020-12-14",
        "url": "https://moeologist.github.io/knapsack/",
        "description": " [src: xkcd]
前言
动态规划一直是我很困扰的一个问题，最近读了一些资料，写了一些代码，顺便把一些经典问题的思路捋了捋，并把过程记录下来。注意：本文内容非常多！",
        "wordCount": 2895
    }
</script>

</article>

    <section id="comments">
    
        
    <!-- Valine -->
    <div class="vcomments"></div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/moeologist" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/var-vs-let/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            JavaScript 走马观花
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/hook-wndproc/" class="thumbnail">
    
    
        <span style="background-image:url(/images/Achievement_Hold_on_Tight.png)" alt="挂钩 Windows 的窗口消息处理函数" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Windows/">Windows</a></p>
                            <p class="item-title"><a href="/hook-wndproc/" class="title">挂钩 Windows 的窗口消息处理函数</a></p>
                            <p class="item-date"><time datetime="2020-10-19T07:51:50.606Z" itemprop="datePublished">2020-10-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/win-font/" class="thumbnail">
    
    
        <span style="background-image:url(/images/font_1080p.png)" alt="Windows 字体折腾指南" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Windows/">Windows</a></p>
                            <p class="item-title"><a href="/win-font/" class="title">Windows 字体折腾指南</a></p>
                            <p class="item-date"><time datetime="2020-10-14T14:15:05.162Z" itemprop="datePublished">2020-10-14</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/clang-constexpr/" class="thumbnail">
    
    
        <span style="background-image:url(/images/things.jpg)" alt="实现 constexpr 数学函数" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/C-C/">C/C++</a></p>
                            <p class="item-title"><a href="/clang-constexpr/" class="title">实现 constexpr 数学函数</a></p>
                            <p class="item-date"><time datetime="2020-10-07T21:44:59.817Z" itemprop="datePublished">2020-10-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/var-vs-let/" class="thumbnail">
    
    
        <span style="background-image:url(/images/js.jpg)" alt="JavaScript 走马观花" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Web/">Web</a></p>
                            <p class="item-title"><a href="/var-vs-let/" class="title">JavaScript 走马观花</a></p>
                            <p class="item-date"><time datetime="2019-08-09T16:01:43.196Z" itemprop="datePublished">2019-08-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/knapsack/" class="thumbnail">
    
    
        <span style="background-image:url(/images/np_complete.png)" alt="动态规划——从入门到入门" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/knapsack/" class="title">动态规划——从入门到入门</a></p>
                            <p class="item-date"><time datetime="2019-08-09T16:01:43.173Z" itemprop="datePublished">2019-08-10</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">2</span></li></ul>
        </div>
    </div>


            
                

            
                

            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo">泛用型自宅机器人</a>
                </h1>
                <p>&copy; 2021 ala</p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script src="//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
    <script>
        var GUEST = ['nick','mail','link'];
        var meta = '';
        meta = meta.split(',').filter(function (item) {
            return GUEST.indexOf(item)>-1;
        });
        var avatarcdn = 'https://gravatar.loli.net/avatar/' == true;
        new Valine({
            el: '.vcomments',
            notify: "",
            verify: "",
            appId: "IgQvaFO0ryAaOY7q5HfUtnUF-gzGzoHsz",
            appKey: "6gmUxC5QhGtJc6cm2Uqw86hP",
            placeholder: "这里支持Markdown语法和Tex公式哦",
            avatar:"retro",
            recordIP:"true",
            visitor: "true"
        });
    </script>





    
    
    
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "$", right: "$", display: false},
                        {left: "\\(", right: "\\)", display: false},
                        {left: "\\[", right: "\\]", display: true}
                    ]
                });
            });
        </script>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
        <script src="//cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
        <script src="//cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"></script>
    
    

    
    
    



<!-- Custom Scripts -->
<script src="/js/main.js" /></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
